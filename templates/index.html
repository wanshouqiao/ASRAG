<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¯­éŸ³ RAG é—®ç­”ç³»ç»Ÿ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 900px;
            width: 100%;
            padding: 40px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 0.9em;
        }

        .status {
            text-align: center;
            padding: 10px;
            margin-bottom: 20px;
            border-radius: 10px;
            font-weight: 500;
        }

        .status.idle {
            background: #e3f2fd;
            color: #1976d2;
        }

        .status.recording {
            background: #ffebee;
            color: #c62828;
            animation: pulse 1.5s infinite;
        }

        .status.processing {
            background: #fff3e0;
            color: #e65100;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
        }

        button {
            padding: 15px 30px;
            font-size: 16px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-record {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-stop {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .btn-clear {
            background: #e0e0e0;
            color: #333;
        }

        .results {
            margin-top: 30px;
        }

        .result-section {
            margin-bottom: 25px;
            padding: 20px;
            border-radius: 10px;
            background: #f5f5f5;
        }

        .result-section h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .result-section h3::before {
            content: "ğŸ“";
            font-size: 1.2em;
        }

        .result-section.answer h3::before {
            content: "ğŸ¤–";
        }

        .result-text {
            color: #555;
            line-height: 1.8;
            font-size: 15px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .result-section.answer {
            background: linear-gradient(135deg, #e0f7fa 0%, #b2ebf2 100%);
        }

        .error {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .loading::after {
            content: "...";
            animation: dots 1.5s steps(4, end) infinite;
        }

        @keyframes dots {
            0%, 20% { content: "."; }
            40% { content: ".."; }
            60%, 100% { content: "..."; }
        }

        .waveform {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 60px;
            margin: 20px 0;
            gap: 4px;
        }

        .waveform-bar {
            width: 4px;
            background: #667eea;
            border-radius: 2px;
            animation: wave 1s ease-in-out infinite;
        }

        .waveform-bar:nth-child(1) { animation-delay: 0s; height: 20px; }
        .waveform-bar:nth-child(2) { animation-delay: 0.1s; height: 35px; }
        .waveform-bar:nth-child(3) { animation-delay: 0.2s; height: 50px; }
        .waveform-bar:nth-child(4) { animation-delay: 0.3s; height: 40px; }
        .waveform-bar:nth-child(5) { animation-delay: 0.4s; height: 30px; }
        .waveform-bar:nth-child(6) { animation-delay: 0.5s; height: 45px; }
        .waveform-bar:nth-child(7) { animation-delay: 0.6s; height: 25px; }
        .waveform-bar:nth-child(8) { animation-delay: 0.7s; height: 40px; }

        @keyframes wave {
            0%, 100% { transform: scaleY(0.5); }
            50% { transform: scaleY(1); }
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¤ è¯­éŸ³ RAG é—®ç­”ç³»ç»Ÿ</h1>
        <p class="subtitle">ç‚¹å‡»å½•éŸ³æŒ‰é’®ï¼Œè¯´å‡ºæ‚¨çš„é—®é¢˜ï¼ŒAI å°†åŸºäºçŸ¥è¯†åº“ä¸ºæ‚¨è§£ç­”</p>

        <div id="status" class="status idle">å‡†å¤‡å°±ç»ª</div>

        <div class="controls">
            <button id="btnRecord" class="btn-record">ğŸ¤ å¼€å§‹å½•éŸ³</button>
            <button id="btnStop" class="btn-stop" disabled>â¹ï¸ åœæ­¢å½•éŸ³</button>
            <button id="btnClear" class="btn-clear">ğŸ—‘ï¸ æ¸…ç©ºè®°å½•</button>
        </div>

        <!-- è¯­éŸ³è¯†åˆ«ç»“æœåŒºåŸŸ -->
        <div id="recognitionResult" class="result-section" style="margin-top:15px; display: none;">
            <h3>è¯†åˆ«ç»“æœ</h3>
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; position: relative;">
                <div id="recognizedText" style="font-size: 1.1em; line-height: 1.6; margin-bottom: 10px; min-height: 30px;"></div>
                <div id="recognitionMeta" style="font-size: 0.85em; color: #666; margin-bottom: 10px;"></div>
                <div style="display: flex; gap: 10px; margin-top: 10px;">
                    <button id="btnCorrect" class="btn-record" style="padding: 8px 16px; font-size: 0.9em;">
                        âœï¸ è¯†åˆ«æœ‰è¯¯ï¼Œç‚¹å‡»çº é”™
                    </button>
                    <button id="btnAccept" class="btn-record" style="padding: 8px 16px; font-size: 0.9em; background: #4CAF50;">
                        âœ“ è¯†åˆ«æ­£ç¡®
                    </button>
                </div>
            </div>
        </div>

        <div class="result-section" style="margin-top:15px; display: flex; gap: 10px;">
            <input type="text" id="textInput" placeholder="æˆ–è€…åœ¨è¿™é‡Œè¾“å…¥æ–‡å­—æé—®..." style="flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd;">
            <button id="btnSend" class="btn-record" style="padding: 10px 20px;">å‘é€</button>
        </div>

        <div class="result-section" style="margin-top:15px;">
            <h3>æ¨¡å‹è®¾ç½®</h3>
            <div style="margin-top:10px; display: flex; align-items: center; gap: 10px;">
                <label for="modelSelect">é€‰æ‹© LLM æ¨¡å‹ï¼š</label>
                <select id="modelSelect" style="padding: 8px; border-radius: 5px; border: 1px solid #ddd;">
                    <option value="local">æœ¬åœ°æ¨¡å‹ (Qwen2.5-7B)</option>
                    <option value="deepseek">DeepSeek API</option>
                </select>
                <span id="modelStatus" style="font-size: 0.9em; color: #666;"></span>
            </div>
            
            <div style="margin-top: 10px;">
                <details>
                    <summary style="cursor: pointer; color: #555; font-size: 0.9em; user-select: none;">âš™ï¸ ASR çƒ­è¯é…ç½®</summary>
                    <div style="margin-top: 10px;">
                        <textarea id="hotwordsInput" rows="3" placeholder="è¯·è¾“å…¥çƒ­è¯ï¼Œæ¯è¡Œä¸€ä¸ª&#10;ä¾‹å¦‚ï¼š&#10;é˜¿é‡Œå·´å·´&#10;è¾¾æ‘©é™¢" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ccc; font-family: monospace; font-size: 0.9em;"></textarea>
                        <div style="font-size: 0.8em; color: #888; margin-top: 5px;">æç¤ºï¼šè¯·è¾“å…¥éœ€è¦é‡ç‚¹è¯†åˆ«çš„è¯æ±‡ï¼Œæ¯è¡Œä¸€ä¸ªã€‚</div>
                    </div>
                </details>
            </div>
        </div>

        <div class="result-section" style="margin-top:15px;">
            <h3>çŸ¥è¯†åº“æ–‡ä»¶ç®¡ç†</h3>
            <div style="margin-top:10px; margin-bottom:15px;">
                <input type="file" id="fileInput" accept=".txt,.md,.pdf" style="margin-right:10px;"/>
                <button id="btnUpload" class="btn-record" style="padding: 8px 15px; font-size: 14px;">ä¸Šä¼ å¹¶æ·»åŠ åˆ°çŸ¥è¯†åº“</button>
                <div id="uploadStatus" class="result-text" style="margin-top:5px; font-size: 0.9em;"></div>
            </div>
            
            <div style="border-top: 1px solid #eee; padding-top: 10px;">
                <h4>å½“å‰çŸ¥è¯†åº“æ–‡ä»¶åˆ—è¡¨ï¼š</h4>
                <div id="fileList" style="margin-top: 10px; max-height: 200px; overflow-y: auto;">
                    <div style="color: #999; font-style: italic;">æ­£åœ¨åŠ è½½...</div>
                </div>
            </div>
        </div>

        <div id="waveform" class="waveform hidden">
            <div class="waveform-bar"></div>
            <div class="waveform-bar"></div>
            <div class="waveform-bar"></div>
            <div class="waveform-bar"></div>
            <div class="waveform-bar"></div>
            <div class="waveform-bar"></div>
            <div class="waveform-bar"></div>
            <div class="waveform-bar"></div>
        </div>

        <div class="results">
            <div id="results"></div>
        </div>
    </div>

    <script>
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let stream = null;
        let lastAsrTime = 0; // å­˜å‚¨æœ€åä¸€æ¬¡ ASR è€—æ—¶
        let lastAudioId = null; // å­˜å‚¨æœ€åä¸€æ¬¡è¯†åˆ«çš„ audio_id
        let lastRecognizedText = ''; // å­˜å‚¨æœ€åä¸€æ¬¡è¯†åˆ«çš„æ–‡æœ¬
        let lastConfidence = 0; // å­˜å‚¨æœ€åä¸€æ¬¡è¯†åˆ«çš„ç½®ä¿¡åº¦
        let lastAudioBase64 = null; // å­˜å‚¨æœ€åä¸€æ¬¡å½•éŸ³çš„ base64 æ•°æ®ï¼ˆå»¶è¿Ÿä¿å­˜ï¼‰

        const btnRecord = document.getElementById('btnRecord');
        const btnStop = document.getElementById('btnStop');
        const btnClear = document.getElementById('btnClear');
        const btnUpload = document.getElementById('btnUpload');
        const btnCorrect = document.getElementById('btnCorrect');
        const btnAccept = document.getElementById('btnAccept');
        const fileInput = document.getElementById('fileInput');
        const uploadStatus = document.getElementById('uploadStatus');
        const status = document.getElementById('status');
        const results = document.getElementById('results');
        const waveform = document.getElementById('waveform');
        const fileList = document.getElementById('fileList');
        const modelSelect = document.getElementById('modelSelect');
        const modelStatus = document.getElementById('modelStatus');
        const textInput = document.getElementById('textInput');
        const btnSend = document.getElementById('btnSend');
        const recognitionResult = document.getElementById('recognitionResult');
        let recognizedTextDiv = document.getElementById('recognizedText');
        const recognitionMeta = document.getElementById('recognitionMeta');

        // åŠ è½½å½“å‰æ¨¡å‹è®¾ç½®
        async function loadModelSettings() {
            try {
                const response = await fetch('/api/model');
                const data = await response.json();
                if (data.success) {
                    modelSelect.value = data.current_model;
                }
            } catch (error) {
                console.error('åŠ è½½æ¨¡å‹è®¾ç½®å¤±è´¥:', error);
            }
        }

        // åˆ‡æ¢æ¨¡å‹
        modelSelect.addEventListener('change', async () => {
            const modelType = modelSelect.value;
            modelStatus.textContent = 'æ­£åœ¨åˆ‡æ¢...';
            modelSelect.disabled = true;
            
            try {
                const response = await fetch('/api/model', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ model_type: modelType })
                });
                
                const data = await response.json();
                if (data.success) {
                    modelStatus.textContent = 'âœ… å·²åˆ‡æ¢';
                    setTimeout(() => { modelStatus.textContent = ''; }, 2000);
                } else {
                    modelStatus.textContent = 'âŒ åˆ‡æ¢å¤±è´¥';
                    alert('åˆ‡æ¢å¤±è´¥: ' + data.error);
                    // æ¢å¤åŸæ¥çš„é€‰æ‹©
                    loadModelSettings();
                }
            } catch (error) {
                console.error('åˆ‡æ¢æ¨¡å‹å¤±è´¥:', error);
                modelStatus.textContent = 'âŒ å‡ºé”™';
                loadModelSettings();
            } finally {
                modelSelect.disabled = false;
            }
        });

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
        loadFiles();
        loadModelSettings();

        // åŠ è½½æ–‡ä»¶åˆ—è¡¨
        async function loadFiles() {
            try {
                const response = await fetch('/api/files');
                const data = await response.json();
                
                if (data.success) {
                    renderFileList(data.files);
                } else {
                    fileList.innerHTML = '<div style="color: red;">åŠ è½½å¤±è´¥</div>';
                }
            } catch (error) {
                console.error('åŠ è½½æ–‡ä»¶åˆ—è¡¨å¤±è´¥:', error);
                fileList.innerHTML = '<div style="color: red;">åŠ è½½å‡ºé”™</div>';
            }
        }

        // æ¸²æŸ“æ–‡ä»¶åˆ—è¡¨
        function renderFileList(files) {
            if (!files || files.length === 0) {
                fileList.innerHTML = '<div style="color: #999;">æš‚æ— æ–‡ä»¶</div>';
                return;
            }

            let html = '<ul style="list-style: none; padding: 0;">';
            files.forEach(file => {
                const date = new Date(file.mtime * 1000).toLocaleString();
                const size = (file.size / 1024).toFixed(1) + ' KB';
                html += `
                    <li style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #f0f0f0;">
                        <div>
                            <div style="font-weight: 500; color: #333;">${file.name}</div>
                            <div style="font-size: 0.8em; color: #999;">${date} Â· ${size}</div>
                        </div>
                        <button onclick="deleteFile('${file.name}')" style="padding: 5px 10px; font-size: 12px; background: #ff5252; color: white; border: none; border-radius: 5px; cursor: pointer;">åˆ é™¤</button>
                    </li>
                `;
            });
            html += '</ul>';
            fileList.innerHTML = html;
        }

        // åˆ é™¤æ–‡ä»¶
        window.deleteFile = async function(filename) {
            if (!confirm(`ç¡®å®šè¦åˆ é™¤æ–‡ä»¶ "${filename}" å—ï¼Ÿè¿™å°†é‡å»ºçŸ¥è¯†åº“ï¼Œå¯èƒ½éœ€è¦ä¸€ç‚¹æ—¶é—´ã€‚`)) {
                return;
            }

            try {
                // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = 'åˆ é™¤ä¸­...';
                btn.disabled = true;

                const response = await fetch('/api/files', {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ filename: filename })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // é‡æ–°åŠ è½½åˆ—è¡¨
                    await loadFiles();
                    showError('æ–‡ä»¶å·²åˆ é™¤ï¼ŒçŸ¥è¯†åº“å·²æ›´æ–°'); // å€Ÿç”¨ showError æ˜¾ç¤ºæç¤ºï¼Œè™½ç„¶å®ƒæ˜¯çº¢è‰²çš„
                } else {
                    alert('åˆ é™¤å¤±è´¥: ' + (data.error || 'æœªçŸ¥é”™è¯¯'));
                    btn.textContent = originalText;
                    btn.disabled = false;
                }
            } catch (error) {
                console.error('åˆ é™¤æ–‡ä»¶å¤±è´¥:', error);
                alert('åˆ é™¤å‡ºé”™: ' + error.message);
            }
        };

        // åŠ è½½çƒ­è¯é…ç½®
        async function loadHotwords() {
            try {
                const response = await fetch('/api/hotwords');
                const data = await response.json();
                if (data.hotwords) {
                    document.getElementById('hotwordsInput').value = data.hotwords;
                }
            } catch (error) {
                console.error('åŠ è½½çƒ­è¯å¤±è´¥:', error);
            }
        }

        // ä¿å­˜çƒ­è¯é…ç½®
        async function saveHotwords() {
            const hotwords = document.getElementById('hotwordsInput').value;
            try {
                await fetch('/api/hotwords', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ hotwords: hotwords })
                });
            } catch (error) {
                console.error('ä¿å­˜çƒ­è¯å¤±è´¥:', error);
            }
        }

        // ç›‘å¬çƒ­è¯è¾“å…¥æ¡†å˜åŒ–
        document.getElementById('hotwordsInput').addEventListener('blur', saveHotwords);

        // é¡µé¢åŠ è½½æ—¶è·å–æ–‡ä»¶åˆ—è¡¨
        loadFiles();
        loadHotwords();

        // å‘é€æ–‡æœ¬
        async function sendText() {
            const text = textInput.value.trim();
            if (!text) return;

            try {
                updateUI('processing');
                textInput.disabled = true;
                btnSend.disabled = true;

                const response = await fetch('/api/text_chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        text: text,
                        audio_id: lastAudioId  // ä¼ é€’ audio_id
                    })
                });

                const data = await response.json();

                if (data.success) {
                    // åˆå¹¶ ASR è€—æ—¶ï¼ˆå¦‚æœæœ‰ï¼‰
                    const timings = data.timings || {};
                    if (lastAsrTime > 0) {
                        timings.asr_time = lastAsrTime;
                        // é‡æ–°è®¡ç®—æ€»è€—æ—¶ï¼ˆè¿‘ä¼¼ï¼‰
                        if (timings.total_time) {
                            timings.total_time += lastAsrTime;
                        }
                        lastAsrTime = 0; // é‡ç½®
                    }
                    
                    displayResult(data.recognized_text, data.answer, data.audio, timings, data.sources, data.audio_id);
                    textInput.value = ''; // æ¸…ç©ºè¾“å…¥æ¡†
                    lastAudioId = null; // é‡ç½® audio_id
                    recognitionResult.style.display = 'none'; // éšè—è¯†åˆ«ç»“æœåŒºåŸŸ
                } else {
                    showError(data.error || 'å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•');
                }
            } catch (error) {
                console.error('å‘é€æ–‡æœ¬å¤±è´¥:', error);
                showError('å‘é€æ–‡æœ¬æ—¶å‡ºé”™: ' + error.message);
            } finally {
                updateUI('idle');
                textInput.disabled = false;
                btnSend.disabled = false;
                textInput.focus();
            }
        }

        btnSend.addEventListener('click', sendText);
        textInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendText();
            }
        });

        // çŠ¶æ€å˜é‡
        let isEditing = false;

        // è¿›å…¥ç¼–è¾‘æ¨¡å¼
        function enterEditMode() {
            if (isEditing) return;
            isEditing = true;

            // è½¬æ¢ä¸ºå¯ç¼–è¾‘çš„textarea
            const textarea = document.createElement('textarea');
            textarea.value = lastRecognizedText;
            textarea.style.width = '100%';
            textarea.style.minHeight = '80px';
            textarea.style.padding = '10px';
            textarea.style.fontSize = '1.1em';
            textarea.style.border = '2px solid #FF9800';
            textarea.style.borderRadius = '5px';
            textarea.style.fontFamily = 'inherit';
            textarea.style.resize = 'vertical';
            textarea.id = 'correctionTextarea';
            
            recognizedTextDiv.replaceWith(textarea);
            textarea.focus();
            textarea.select();
            
            // æ›´æ–°æŒ‰é’®
            btnCorrect.textContent = 'âœ“ æäº¤ä¿®æ­£';
            btnCorrect.style.background = '#4CAF50';
            btnCorrect.onclick = submitCorrection;
            
            btnAccept.textContent = 'âœ— å–æ¶ˆ';
            btnAccept.style.background = '#f44336';
            btnAccept.onclick = cancelEdit;
        }

        // æäº¤çº é”™
        async function submitCorrection() {
            const textarea = document.getElementById('correctionTextarea');
            if (!textarea) return;

            const correctedText = textarea.value.trim();
            
            if (!correctedText) {
                alert('ä¿®æ­£æ–‡æœ¬ä¸èƒ½ä¸ºç©º');
                return;
            }
            
            if (correctedText === lastRecognizedText) {
                cancelEdit();
                return;
            }
            
            try {
                // ä¿å­˜è¯†åˆ«æ•°æ®ï¼ˆå¸¦çº é”™æ–‡æœ¬ï¼‰
                await saveRecognitionData(lastRecognizedText, correctedText);
                
                // æ›´æ–°è¾“å…¥æ¡†ä¸ºä¿®æ­£åçš„æ–‡æœ¬
                textInput.value = correctedText;
                
                // éšè—è¯†åˆ«ç»“æœåŒºåŸŸ
                recognitionResult.style.display = 'none';
                
                // èšç„¦åˆ°è¾“å…¥æ¡†
                textInput.focus();

                // æ¢å¤ç•Œé¢çŠ¶æ€
                resetInterface(correctedText);
                
            } catch (error) {
                console.error('æäº¤çº é”™å¤±è´¥:', error);
                alert('æäº¤å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
            }
        }

        // å–æ¶ˆç¼–è¾‘
        function cancelEdit() {
            resetInterface(lastRecognizedText);
        }

        // æ¢å¤ç•Œé¢çŠ¶æ€
        function resetInterface(textToShow) {
            const textarea = document.getElementById('correctionTextarea');
            const textDiv = document.createElement('div');
            textDiv.id = 'recognizedText';
            textDiv.style.cssText = 'font-size: 1.1em; line-height: 1.6; margin-bottom: 10px; min-height: 30px;';
            textDiv.textContent = textToShow;
            
            if (textarea) {
                textarea.replaceWith(textDiv);
            } else if (recognizedTextDiv && recognizedTextDiv.parentNode) {
                recognizedTextDiv.replaceWith(textDiv);
            }
            
            recognizedTextDiv = textDiv; // æ›´æ–°å¼•ç”¨
            isEditing = false;
            
            // æ¢å¤æŒ‰é’®
            btnCorrect.textContent = 'âœï¸ è¯†åˆ«æœ‰è¯¯ï¼Œç‚¹å‡»çº é”™';
            btnCorrect.style.background = '';
            btnCorrect.onclick = enterEditMode;
            
            btnAccept.textContent = 'âœ“ è¯†åˆ«æ­£ç¡®';
            btnAccept.style.background = '#4CAF50';
            btnAccept.onclick = acceptRecognition;
        }

        // ä¿å­˜è¯†åˆ«æ•°æ®åˆ°åç«¯
        async function saveRecognitionData(recognizedText, correctedText = null) {
            try {
                const response = await fetch('/api/save_recognition', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        audio_base64: lastAudioBase64,
                        recognized_text: recognizedText,
                        corrected_text: correctedText,
                        confidence: lastConfidence
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    console.log('è¯†åˆ«æ•°æ®å·²ä¿å­˜:', data.audio_id);
                    lastAudioId = data.audio_id; // æ›´æ–°ä¸ºçœŸå®çš„ audio_id
                } else {
                    console.error('ä¿å­˜è¯†åˆ«æ•°æ®å¤±è´¥:', data.error);
                }
            } catch (error) {
                console.error('ä¿å­˜è¯†åˆ«æ•°æ®æ—¶å‡ºé”™:', error);
            }
        }
        
        // æ¥å—è¯†åˆ«ç»“æœ
        async function acceptRecognition() {
            // ä¿å­˜è¯†åˆ«æ•°æ®ï¼ˆè¯†åˆ«æ­£ç¡®ï¼Œæ— çº é”™ï¼‰
            await saveRecognitionData(lastRecognizedText, null);
            
            // éšè—è¯†åˆ«ç»“æœåŒºåŸŸ
            recognitionResult.style.display = 'none';
            // èšç„¦åˆ°è¾“å…¥æ¡†
            textInput.focus();
        }
        
        // åˆå§‹ç»‘å®š
        btnCorrect.onclick = enterEditMode;
        btnAccept.onclick = acceptRecognition;

        // å¼€å§‹å½•éŸ³
        btnRecord.addEventListener('click', async () => {
            try {
                stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus'
                });

                audioChunks = [];

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = async () => {
                    await processAudio();
                };

                mediaRecorder.start();
                isRecording = true;
                updateUI('recording');
                
            } catch (error) {
                console.error('æ— æ³•è®¿é—®éº¦å…‹é£:', error);
                showError('æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®');
            }
        });

        // åœæ­¢å½•éŸ³
        btnStop.addEventListener('click', () => {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                
                // åœæ­¢æ‰€æœ‰éŸ³é¢‘è½¨é“
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }
                
                updateUI('processing');
            }
        });

        // æ¸…ç©ºè®°å½•
        btnClear.addEventListener('click', () => {
            results.innerHTML = '';
            lastAudioId = null; // æ¸…ç©ºå†å²è®°å½•æ—¶ä¹Ÿé‡ç½® audio_id
            recognitionResult.style.display = 'none'; // éšè—è¯†åˆ«ç»“æœåŒºåŸŸ
        });

        // ä¸Šä¼ çŸ¥è¯†åº“æ–‡ä»¶
        btnUpload.addEventListener('click', async () => {
            if (!fileInput.files || fileInput.files.length === 0) {
                showError('è¯·å…ˆé€‰æ‹©è¦ä¸Šä¼ çš„æ–‡ä»¶');
                return;
            }
            const file = fileInput.files[0];
            const formData = new FormData();
            formData.append('file', file);
            uploadStatus.textContent = 'æ­£åœ¨ä¸Šä¼ å¹¶å‘é‡åŒ–...';

            try {
                const resp = await fetch('/api/upload_kb', {
                    method: 'POST',
                    body: formData
                });
                const data = await resp.json();
                if (data.success) {
                    uploadStatus.textContent = `ä¸Šä¼ æˆåŠŸï¼š${file.name}ã€‚å·²æ·»åŠ åˆ°çŸ¥è¯†åº“ã€‚`;
                    loadFiles(); // åˆ·æ–°åˆ—è¡¨
                } else {
                    uploadStatus.textContent = `ä¸Šä¼ å¤±è´¥ï¼š${data.error || 'æœªçŸ¥é”™è¯¯'}`;
                }
            } catch (e) {
                uploadStatus.textContent = `ä¸Šä¼ å¤±è´¥ï¼š${e.message}`;
            }
        });

        // è·å–çƒ­è¯é…ç½®
        function getHotwords() {
            const input = document.getElementById('hotwordsInput').value.trim();
            if (!input) return '';
            
            const lines = input.split('\n');
            const words = [];
            
            for (const line of lines) {
                let part = line.trim();
                if (!part) continue;
                
                // å°è¯•åˆ†ç¦»æƒé‡ï¼ˆå¦‚æœæœ‰ï¼‰ï¼Œä½†ç›®å‰åªä½¿ç”¨è¯æœ¬èº«ï¼Œå› ä¸º JSON æ ¼å¼å¯èƒ½ä¸è¢«æ”¯æŒ
                // å‡è®¾æ ¼å¼æ˜¯ "è¯è¯­ æƒé‡" æˆ– "è¯è¯­"
                const parts = part.split(/\s+/);
                if (parts.length > 1) {
                    const lastPart = parts[parts.length - 1];
                    if (!isNaN(parseInt(lastPart))) {
                        // æœ€åä¸€ä¸ªæ˜¯æ•°å­—ï¼Œè®¤ä¸ºæ˜¯æƒé‡ï¼Œå»æ‰å®ƒ
                        part = parts.slice(0, parts.length - 1).join(' ');
                    }
                }
                if (part) words.push(part);
            }
            
            // è¿”å›ç©ºæ ¼åˆ†éš”çš„å­—ç¬¦ä¸²ï¼Œè€Œä¸æ˜¯ JSON
            return words.join(' ');
        }

        // å¤„ç†éŸ³é¢‘
        async function processAudio() {
            try {
                updateUI('processing');
                
                // å°†éŸ³é¢‘è½¬æ¢ä¸º WAV æ ¼å¼
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                const wavBlob = await convertToWav(audioBlob);
                
                // å‘é€åˆ°æœåŠ¡å™¨
                const formData = new FormData();
                formData.append('audio', wavBlob, 'recording.wav');
                
                // æ·»åŠ çƒ­è¯
                const hotwords = getHotwords();
                if (hotwords) {
                    formData.append('hotwords', hotwords);
                }
                
                // æ”¹ä¸ºåªè°ƒç”¨è¯†åˆ«æ¥å£
                const response = await fetch('/api/recognize', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // ä¿å­˜è¯†åˆ«ç»“æœï¼ˆä¸ç«‹å³ä¿å­˜æ•°æ®ï¼Œç­‰å¾…ç”¨æˆ·ç¡®è®¤ï¼‰
                    lastRecognizedText = data.text;
                    lastAudioId = data.temp_id || data.audio_id; // ä½¿ç”¨ä¸´æ—¶ID
                    lastConfidence = data.confidence || 0;
                    lastAudioBase64 = data.audio_base64; // å­˜å‚¨éŸ³é¢‘æ•°æ®
                    
                    // ä¿å­˜ ASR è€—æ—¶
                    if (data.timings && data.timings.asr_time) {
                        lastAsrTime = data.timings.asr_time;
                    }
                    
                    // æ˜¾ç¤ºè¯†åˆ«ç»“æœåŒºåŸŸ
                    recognizedTextDiv.textContent = data.text;
                    recognitionMeta.innerHTML = `
                        <span>è€—æ—¶: ${data.timings.asr_time.toFixed(2)}s</span>
                        ${data.confidence > 0 ? ` | <span>ç½®ä¿¡åº¦: ${(data.confidence * 100).toFixed(1)}%</span>` : ''}
                        ${data.audio_id ? ` | <span style="font-size: 0.8em; color: #999;">ID: ${data.audio_id}</span>` : ''}
                    `;
                    recognitionResult.style.display = 'block';
                    
                    // åŒæ—¶å¡«å…¥è¾“å…¥æ¡†
                    textInput.value = data.text;
                    
                    updateUI('idle');
                    
                    // æç¤ºç”¨æˆ·
                    const statusDiv = document.getElementById('status');
                    statusDiv.textContent = 'è¯†åˆ«å®Œæˆï¼Œè¯·ç¡®è®¤è¯†åˆ«ç»“æœ';
                    setTimeout(() => {
                        if (statusDiv.textContent === 'è¯†åˆ«å®Œæˆï¼Œè¯·ç¡®è®¤è¯†åˆ«ç»“æœ') {
                            statusDiv.textContent = 'å‡†å¤‡å°±ç»ª';
                        }
                    }, 3000);
                    
                } else {
                    showError(data.error || 'è¯†åˆ«å¤±è´¥ï¼Œè¯·é‡è¯•');
                    updateUI('idle');
                }
                
            } catch (error) {
                console.error('å¤„ç†éŸ³é¢‘å¤±è´¥:', error);
                showError('å¤„ç†éŸ³é¢‘æ—¶å‡ºé”™: ' + error.message);
                updateUI('idle');
            }
        }

        // å°†éŸ³é¢‘è½¬æ¢ä¸º WAV æ ¼å¼
        async function convertToWav(audioBlob) {
            return new Promise(async (resolve, reject) => {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const arrayBuffer = await audioBlob.arrayBuffer();
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    
                    // è½¬æ¢ä¸º 16kHz å•å£°é“
                    const targetSampleRate = 16000;
                    const offlineContext = new OfflineAudioContext(
                        1, 
                        Math.ceil(audioBuffer.duration * targetSampleRate), 
                        targetSampleRate
                    );
                    const source = offlineContext.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(offlineContext.destination);
                    source.start();
                    
                    const resampledBuffer = await offlineContext.startRendering();
                    
                    // è½¬æ¢ä¸º WAV
                    const wav = audioBufferToWav(resampledBuffer);
                    const wavBlob = new Blob([wav], { type: 'audio/wav' });
                    resolve(wavBlob);
                } catch (error) {
                    console.error('éŸ³é¢‘è½¬æ¢å¤±è´¥:', error);
                    reject(error);
                }
            });
        }

        // AudioBuffer è½¬ WAV
        function audioBufferToWav(buffer) {
            const length = buffer.length;
            const arrayBuffer = new ArrayBuffer(44 + length * 2);
            const view = new DataView(arrayBuffer);
            const samples = buffer.getChannelData(0);
            
            // WAV æ–‡ä»¶å¤´
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + length * 2, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);  // PCM
            view.setUint16(22, 1, true);  // å•å£°é“
            view.setUint32(24, buffer.sampleRate, true);
            view.setUint32(28, buffer.sampleRate * 2, true);
            view.setUint16(32, 2, true);  // å­—èŠ‚å¯¹é½
            view.setUint16(34, 16, true); // ä½æ·±åº¦
            writeString(36, 'data');
            view.setUint32(40, length * 2, true);
            
            // å†™å…¥ PCM æ•°æ®
            let offset = 44;
            for (let i = 0; i < length; i++) {
                const sample = Math.max(-1, Math.min(1, samples[i]));
                view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                offset += 2;
            }
            
            return arrayBuffer;
        }

        // æ›´æ–° UI çŠ¶æ€
        function updateUI(state) {
            status.className = `status ${state}`;
            
            switch(state) {
                case 'idle':
                    status.textContent = 'å‡†å¤‡å°±ç»ª';
                    btnRecord.disabled = false;
                    btnStop.disabled = true;
                    waveform.classList.add('hidden');
                    break;
                case 'recording':
                    status.textContent = 'æ­£åœ¨å½•éŸ³...';
                    btnRecord.disabled = true;
                    btnStop.disabled = false;
                    waveform.classList.remove('hidden');
                    break;
                case 'processing':
                    status.textContent = 'æ­£åœ¨å¤„ç†';
                    btnRecord.disabled = true;
                    btnStop.disabled = true;
                    waveform.classList.add('hidden');
                    break;
            }
        }

        // æ˜¾ç¤ºç»“æœ
        function displayResult(recognizedText, answer, audioData, timings, sources, audioId) {
            const resultDiv = document.createElement('div');
            
            let audioHTML = '';
            if (audioData) {
                audioHTML = `
                    <div style="margin-top: 15px;">
                        <audio controls style="width: 100%; max-width: 500px;">
                            <source src="${audioData}" type="audio/wav">
                            æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘æ’­æ”¾ã€‚
                            </audio>
                    </div>
                `;
            }

            let timingsHTML = '';
            if (timings) {
                timingsHTML = '<div style="margin-top: 10px; font-size: 0.85em; color: #666; border-top: 1px solid #eee; padding-top: 10px;">';
                if (timings.asr_time) timingsHTML += `<span>ASR: ${timings.asr_time.toFixed(2)}s</span> | `;
                if (timings.rag_time) {
                    timingsHTML += `<span>RAG: ${timings.rag_time.toFixed(2)}s`;
                    if (timings.retrieval && timings.llm_generation) {
                        timingsHTML += ` (æ£€ç´¢: ${timings.retrieval.toFixed(2)}s, ç”Ÿæˆ: ${timings.llm_generation.toFixed(2)}s)`;
                    }
                    timingsHTML += `</span> | `;
                }
                if (timings.tts_time) timingsHTML += `<span>TTS: ${timings.tts_time.toFixed(2)}s</span> | `;
                if (timings.total_time) timingsHTML += `<span>Total: ${timings.total_time.toFixed(2)}s</span>`;
                timingsHTML += '</div>';
            }

            let sourcesHTML = '';
            if (sources && sources.length > 0) {
                sourcesHTML = `
                    <div style="margin-top: 15px; border-top: 1px solid #eee; padding-top: 10px;">
                        <details>
                            <summary style="cursor: pointer; color: #666; font-size: 0.9em; user-select: none;">
                                ğŸ“š å‚è€ƒå¼•ç”¨ (${sources.length})
                            </summary>
                            <div style="margin-top: 10px; font-size: 0.9em; color: #555; background: #fff; padding: 10px; border-radius: 5px; border: 1px solid #eee;">
                                ${sources.map((s, i) => `
                                    <div style="margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px dashed #eee;">
                                        <div style="font-weight: bold; color: #333; margin-bottom: 5px;">[${i+1}] ${s.source}</div>
                                        <div style="line-height: 1.5;">${s.content}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </details>
                    </div>
                `;
            }
            
            resultDiv.innerHTML = `
                <div class="result-section">
                    <h3>ç”¨æˆ·é—®é¢˜</h3>
                    <div class="result-text">${recognizedText}</div>
                </div>
                <div class="result-section answer">
                    <h3>AI å›ç­”</h3>
                    <div class="result-text">${answer}</div>
                    ${sourcesHTML}
                    ${audioHTML}
                    ${timingsHTML}
                </div>
            `;
            results.insertBefore(resultDiv, results.firstChild);
            
            // è‡ªåŠ¨æ’­æ”¾éŸ³é¢‘ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            if (audioData) {
                const audio = resultDiv.querySelector('audio');
                if (audio) {
                    audio.play().catch(e => {
                        console.log('è‡ªåŠ¨æ’­æ”¾è¢«é˜»æ­¢ï¼Œç”¨æˆ·éœ€è¦æ‰‹åŠ¨ç‚¹å‡»æ’­æ”¾');
                    });
                }
            }
        }
        
        // æ˜¾ç¤ºé”™è¯¯
        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = 'âŒ ' + message;
            results.insertBefore(errorDiv, results.firstChild);
            
            setTimeout(() => {
                errorDiv.remove();
            }, 5000);
        }
    </script>
</body>
</html>

