<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¯­éŸ³ RAG é—®ç­”ç³»ç»Ÿ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 900px;
            width: 100%;
            padding: 40px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 0.9em;
        }

        .status {
            text-align: center;
            padding: 10px;
            margin-bottom: 20px;
            border-radius: 10px;
            font-weight: 500;
        }

        .status.idle {
            background: #e3f2fd;
            color: #1976d2;
        }

        .status.recording {
            background: #ffebee;
            color: #c62828;
            animation: pulse 1.5s infinite;
        }

        .status.processing {
            background: #fff3e0;
            color: #e65100;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
        }

        button {
            padding: 15px 30px;
            font-size: 16px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-record {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-stop {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .btn-clear {
            background: #e0e0e0;
            color: #333;
        }

        .results {
            margin-top: 30px;
        }

        .result-section {
            margin-bottom: 25px;
            padding: 20px;
            border-radius: 10px;
            background: #f5f5f5;
        }

        .result-section h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .result-section h3::before {
            content: "ğŸ“";
            font-size: 1.2em;
        }

        .result-section.answer h3::before {
            content: "ğŸ¤–";
        }

        .result-text {
            color: #555;
            line-height: 1.8;
            font-size: 15px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .result-section.answer {
            background: linear-gradient(135deg, #e0f7fa 0%, #b2ebf2 100%);
        }

        .error {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .loading::after {
            content: "...";
            animation: dots 1.5s steps(4, end) infinite;
        }

        @keyframes dots {
            0%, 20% { content: "."; }
            40% { content: ".."; }
            60%, 100% { content: "..."; }
        }

        .waveform {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 60px;
            margin: 20px 0;
            gap: 4px;
        }

        .waveform-bar {
            width: 4px;
            background: #667eea;
            border-radius: 2px;
            animation: wave 1s ease-in-out infinite;
        }

        .waveform-bar:nth-child(1) { animation-delay: 0s; height: 20px; }
        .waveform-bar:nth-child(2) { animation-delay: 0.1s; height: 35px; }
        .waveform-bar:nth-child(3) { animation-delay: 0.2s; height: 50px; }
        .waveform-bar:nth-child(4) { animation-delay: 0.3s; height: 40px; }
        .waveform-bar:nth-child(5) { animation-delay: 0.4s; height: 30px; }
        .waveform-bar:nth-child(6) { animation-delay: 0.5s; height: 45px; }
        .waveform-bar:nth-child(7) { animation-delay: 0.6s; height: 25px; }
        .waveform-bar:nth-child(8) { animation-delay: 0.7s; height: 40px; }

        @keyframes wave {
            0%, 100% { transform: scaleY(0.5); }
            50% { transform: scaleY(1); }
        }

        .hidden {
            display: none;
        }

        .admin-link {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            font-size: 0.9em;
            color: #1976d2;
            text-decoration: none;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            transition: all 0.3s;
        }

        .admin-link:hover {
            background: rgba(255, 255, 255, 1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            transform: translateY(-2px);
        }

        /* è¯­éŸ³åŠ¨æ•ˆï¼ˆç”¨æˆ·è¯´è¯/AIè¯´è¯ï¼‰*/
        .equalizer { display:flex; gap:3px; align-items:flex-end; height:22px; }
        .equalizer span { width:3px; background:#4CAF50; display:block; border-radius:2px; height:8px; transition: height .08s linear; }
        #assistantSpeaking { position: fixed; right: 18px; bottom: 32px; background: rgba(0,0,0,.7); color:#fff; border-radius:12px; padding:8px 10px; display:flex; align-items:center; gap:8px; z-index:1000; }
        /* ä¸€é”®éšè—å¤æ‚æ¨¡å—ï¼ˆä½†ä¸åˆ é™¤ï¼‰ */
        #recognitionResult{ display:none !important; }
        #btnClear{ display:none !important; }

        .image-preview {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 8px;
            background: #f8f9fa;
            border: 1px dashed #ddd;
            padding: 10px;
            border-radius: 8px;
        }

        /* ä¿è¯æœªé€‰å›¾æ—¶éšè—é¢„è§ˆ */
        .image-preview.hidden {
            display: none !important;
        }

        /* ç§»åŠ¨ç«¯é€‚é… */
        @media (max-width: 640px) {
            #chatInputBar {
                flex-direction: column;
                align-items: stretch;
            }
            #chatInputBar input[type="text"],
            #chatInputBar button {
                width: 100%;
            }
            #chatInputBar button {
                min-height: 44px;
                font-size: 16px;
            }
            #imagePreview {
                width: 100%;
            }
            .admin-link {
                top: 12px;
                right: 12px;
                padding: 6px 12px;
                font-size: 0.85em;
            }
        }

        .image-preview img {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border-radius: 6px;
            border: 1px solid #eee;
        }

        .image-preview .meta {
            flex: 1;
            color: #555;
            font-size: 0.9em;
        }

        .image-preview button {
            padding: 6px 10px;
            font-size: 12px;
            background: #ff7043;
            color: white;
        }
    </style>
</head>
<body>
    <a href="/admin" class="admin-link">è¿›å…¥ç®¡ç†ç«¯ â–¶</a>
    <div class="container">
        <h1>ğŸ¤ è¯­éŸ³ RAG é—®ç­”ç³»ç»Ÿ</h1>
        <p class="subtitle">è¯´å‡ºæ‚¨çš„é—®é¢˜ï¼ŒAI å°†åŸºäºçŸ¥è¯†åº“ä¸ºæ‚¨è§£ç­”</p>

        <div id="status" class="status idle">å‡†å¤‡å°±ç»ª</div>

        <!-- SSL è‡ªç­¾è¯ä¹¦ä¿¡ä»»æç¤º -->
        <div id="ssl-auth-hint" style="display:none; text-align:center; margin-bottom:15px; background:#fff3cd; color:#856404; padding:10px; border-radius:8px; border:1px solid #ffeeba; font-size: 0.9em;">
            âš ï¸ è¿æ¥å¤±è´¥ã€‚å¦‚æœæ˜¯è‡ªç­¾è¯ä¹¦ï¼Œè¯· <a id="ssl-auth-link" href="#" target="_blank" style="color:#856404; font-weight:bold; text-decoration:underline;">ç‚¹å‡»æ­¤å¤„æ‰“å¼€ WSS æœåŠ¡</a><br>å¹¶é€‰æ‹©â€œé«˜çº§ -> ç»§ç»­è®¿é—®â€æˆ–â€œæ¥å—é£é™©â€ï¼Œç„¶ååˆ·æ–°æœ¬é¡µã€‚
        </div>

        <div class="controls">
            <button id="btnClear" class="btn-clear">ğŸ—‘ï¸ æ¸…ç©ºè®°å½•</button>
        </div>

        <!-- å”¤é†’è¯æ§åˆ¶åŒº -->
        <div class="result-section" style="margin-top:15px;">
            <div style="display:flex; flex-direction:column; align-items:center; gap:10px; margin-top:10px;">
                <div style="display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap: wrap;">
                    <button id="btnWakeEnableMic" class="btn-record" style="background:#2196F3;">ğŸ¤ å¯ç”¨ç›‘å¬</button>
                    <button id="btnWakeBypass" class="btn-stop">â­ï¸ è·³è¿‡å”¤é†’è¯</button>
                </div>
                <span id="wakeStatus" style="font-size:0.9em; color:#666;">åˆå§‹åŒ–ä¸­...</span>
            </div>
        </div>

        <!-- è¯­éŸ³è¯†åˆ«ç»“æœåŒºåŸŸ -->
        <div id="recognitionResult" class="result-section" style="margin-top:15px; display: none;">
            <h3>è¯†åˆ«ç»“æœ</h3>
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; position: relative;">
                <div id="recognizedText" style="font-size: 1.1em; line-height: 1.6; margin-bottom: 10px; min-height: 30px;"></div>
                <div id="recognitionMeta" style="font-size: 0.85em; color: #666; margin-bottom: 10px;"></div>
                <div style="display: flex; gap: 10px; margin-top: 10px;">
                    <button id="btnCorrect" class="btn-record" style="padding: 8px 16px; font-size: 0.9em;">
                        âœï¸ è¯†åˆ«æœ‰è¯¯ï¼Œç‚¹å‡»çº é”™
                    </button>
                    <button id="btnAccept" class="btn-record" style="padding: 8px 16px; font-size: 0.9em; background: #4CAF50;">
                        âœ“ è¯†åˆ«æ­£ç¡®
                    </button>
                </div>
            </div>
        </div>

        <div id="chatInputBar" class="result-section" style="margin-top:15px; display:flex; gap: 10px; align-items: center;">
            <input type="text" id="textInput" placeholder="æˆ–è€…åœ¨è¿™é‡Œè¾“å…¥æ–‡å­—æé—®..." style="flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd;">
            <input type="file" id="imageInput" accept="image/png,image/jpeg,image/webp" class="hidden">
            <button id="btnImage" class="btn-record" style="padding: 10px 14px; white-space: nowrap; background:#42A5F5;">ğŸ“· ä¸Šä¼ å›¾ç‰‡</button>
            <button id="btnSend" class="btn-record" style="padding: 10px 20px; background:#1E88E5;">å‘é€</button>
        </div>
        <div id="imagePreview" class="image-preview hidden">
            <img id="imageThumb" alt="é¢„è§ˆ">
            <div class="meta">
                <div id="imageName"></div>
                <div id="imageSize" style="color:#888;"></div>
            </div>
            <button id="btnClearImage" class="btn-clear" style="background:#ff7043;color:#fff;">ç§»é™¤</button>
        </div>

        <div class="result-section" style="margin-top:15px; display:none;">
            <h3>æ¨¡å‹è®¾ç½®</h3>
            <div style="margin-top:10px; display: flex; align-items: center; gap: 10px;">
                <label for="modelSelect">é€‰æ‹© LLM æ¨¡å‹ï¼š</label>
                <select id="modelSelect" style="padding: 8px; border-radius: 5px; border: 1px solid #ddd;">
                    <option value="local">æœ¬åœ°æ¨¡å‹ (Qwen2.5-7B)</option>
                    <option value="deepseek">DeepSeek API</option>
                </select>
                <span id="modelStatus" style="font-size: 0.9em; color: #666;"></span>
            </div>
            
            <div style="margin-top: 10px;">
                <details>
                    <summary style="cursor: pointer; color: #555; font-size: 0.9em; user-select: none;">âš™ï¸ ASR çƒ­è¯é…ç½®</summary>
                    <div style="margin-top: 10px;">
                        <textarea id="hotwordsInput" rows="3" placeholder="è¯·è¾“å…¥çƒ­è¯ï¼Œæ¯è¡Œä¸€ä¸ª&#10;ä¾‹å¦‚ï¼š&#10;é˜¿é‡Œå·´å·´&#10;è¾¾æ‘©é™¢" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ccc; font-family: monospace; font-size: 0.9em;"></textarea>
                        <div style="font-size: 0.8em; color: #888; margin-top: 5px;">æç¤ºï¼šè¯·è¾“å…¥éœ€è¦é‡ç‚¹è¯†åˆ«çš„è¯æ±‡ï¼Œæ¯è¡Œä¸€ä¸ªã€‚</div>
                    </div>
                </details>
            </div>
        </div>

        <div class="result-section" style="margin-top:15px; display:none;">
            <h3>çŸ¥è¯†åº“æ–‡ä»¶ç®¡ç†</h3>
            <div style="margin-top:10px; margin-bottom:15px;">
                <input type="file" id="fileInput" accept=".txt,.md,.pdf,.jpg,.jpeg,.png,.webp,.gif,.bmp,image/*" style="margin-right:10px;"/>
                <button id="btnUpload" class="btn-record" style="padding: 8px 15px; font-size: 14px;">ä¸Šä¼ å¹¶æ·»åŠ åˆ°çŸ¥è¯†åº“</button>
                <div id="uploadStatus" class="result-text" style="margin-top:5px; font-size: 0.9em;"></div>
            </div>
            
            <div style="border-top: 1px solid #eee; padding-top: 10px;">
                <h4>å½“å‰çŸ¥è¯†åº“æ–‡ä»¶åˆ—è¡¨ï¼š</h4>
                <div id="fileList" style="margin-top: 10px; max-height: 200px; overflow-y: auto;">
                    <div style="color: #999; font-style: italic;">æ­£åœ¨åŠ è½½...</div>
                </div>
            </div>
        </div>

        <div id="waveform" class="waveform hidden">
            <div class="waveform-bar"></div>
            <div class="waveform-bar"></div>
            <div class="waveform-bar"></div>
            <div class="waveform-bar"></div>
            <div class="waveform-bar"></div>
            <div class="waveform-bar"></div>
            <div class="waveform-bar"></div>
            <div class="waveform-bar"></div>
        </div>

        <div class="results">
            <div id="results"></div>
        </div>
    </div>

    <!-- AI è¯´è¯åŠ¨æ•ˆï¼ˆTTS æ’­æ”¾æ—¶æ˜¾ç¤ºï¼‰ -->
    <div id="assistantSpeaking" style="display:none;">
        <div class="equalizer" id="assistantEq">
            <span></span><span></span><span></span><span></span><span></span>
        </div>
        <div style="font-size:12px; opacity:.9;">AI è¯´è¯ä¸­...</div>
    </div>

    <script>

        let lastAsrTime = 0; // å­˜å‚¨æœ€åä¸€æ¬¡ ASR è€—æ—¶
        let lastAudioId = null; // å­˜å‚¨æœ€åä¸€æ¬¡è¯†åˆ«çš„ audio_id
        let lastRecognizedText = ''; // å­˜å‚¨æœ€åä¸€æ¬¡è¯†åˆ«çš„æ–‡æœ¬
        let lastConfidence = 0; // å­˜å‚¨æœ€åä¸€æ¬¡è¯†åˆ«çš„ç½®ä¿¡åº¦
        let lastAudioBase64 = null; // å­˜å‚¨æœ€åä¸€æ¬¡å½•éŸ³çš„ base64 æ•°æ®ï¼ˆå»¶è¿Ÿä¿å­˜ï¼‰


        const btnClear = document.getElementById('btnClear');
        const btnUpload = document.getElementById('btnUpload');
        const btnCorrect = document.getElementById('btnCorrect');
        const btnAccept = document.getElementById('btnAccept');
        const fileInput = document.getElementById('fileInput');
        const uploadStatus = document.getElementById('uploadStatus');
        const status = document.getElementById('status');
        const results = document.getElementById('results');
        const waveform = document.getElementById('waveform');
        const fileList = document.getElementById('fileList');
        const modelSelect = document.getElementById('modelSelect');
        const modelStatus = document.getElementById('modelStatus');
        const textInput = document.getElementById('textInput');
        const btnSend = document.getElementById('btnSend');
        const btnImage = document.getElementById('btnImage');
        const imageInput = document.getElementById('imageInput');
        const imagePreview = document.getElementById('imagePreview');
        const imageThumb = document.getElementById('imageThumb');
        const imageName = document.getElementById('imageName');
        const imageSize = document.getElementById('imageSize');
        const btnClearImage = document.getElementById('btnClearImage');
        const recognitionResult = document.getElementById('recognitionResult');
        let recognizedTextDiv = document.getElementById('recognizedText');
        const recognitionMeta = document.getElementById('recognitionMeta');

        // ======= AI è¯´è¯åŠ¨æ•ˆ =======
        const assistantSpeaking = document.getElementById('assistantSpeaking');
        const assistantEq = document.getElementById('assistantEq');
        let eqTimer = null;
        function startAssistantEq(){
            assistantSpeaking.style.display = 'flex';
            const bars = assistantEq ? assistantEq.querySelectorAll('span') : [];
            if (eqTimer) clearInterval(eqTimer);
            eqTimer = setInterval(()=>{
                bars.forEach((b,i)=>{ b.style.height = (6 + Math.random()*16) + 'px'; });
            }, 80);
        }
        function stopAssistantEq(){
            if (eqTimer) { clearInterval(eqTimer); eqTimer = null; }
            const bars = assistantEq ? assistantEq.querySelectorAll('span') : [];
            bars.forEach(b=> b.style.height='8px');
            assistantSpeaking.style.display = 'none';
        }
        // ======= ç»“æŸï¼šAI è¯´è¯åŠ¨æ•ˆ =======
        const MAX_IMAGE_SIZE = 2 * 1024 * 1024; // 2MB é™åˆ¶

        // åŠ è½½å½“å‰æ¨¡å‹è®¾ç½®
        async function loadModelSettings() {
            try {
                const response = await fetch('/api/model');
                const data = await response.json();
                if (data.success) {
                    modelSelect.value = data.current_model;
                }
            } catch (error) {
                console.error('åŠ è½½æ¨¡å‹è®¾ç½®å¤±è´¥:', error);
            }
        }

        // åˆ‡æ¢æ¨¡å‹
        modelSelect.addEventListener('change', async () => {
            const modelType = modelSelect.value;
            modelStatus.textContent = 'æ­£åœ¨åˆ‡æ¢...';
            modelSelect.disabled = true;
            
            try {
                const response = await fetch('/api/model', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ model_type: modelType })
                });
                
                const data = await response.json();
                if (data.success) {
                    modelStatus.textContent = 'âœ… å·²åˆ‡æ¢';
                    setTimeout(() => { modelStatus.textContent = ''; }, 2000);
                } else {
                    modelStatus.textContent = 'âŒ åˆ‡æ¢å¤±è´¥';
                    alert('åˆ‡æ¢å¤±è´¥: ' + data.error);
                    // æ¢å¤åŸæ¥çš„é€‰æ‹©
                    loadModelSettings();
                }
            } catch (error) {
                console.error('åˆ‡æ¢æ¨¡å‹å¤±è´¥:', error);
                modelStatus.textContent = 'âŒ å‡ºé”™';
                loadModelSettings();
            } finally {
                modelSelect.disabled = false;
            }
        });

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
        loadFiles();
        loadModelSettings();

        // åŠ è½½æ–‡ä»¶åˆ—è¡¨
        async function loadFiles() {
            try {
                const response = await fetch('/api/files');
                const data = await response.json();
                
                if (data.success) {
                    renderFileList(data.files);
                } else {
                    fileList.innerHTML = '<div style="color: red;">åŠ è½½å¤±è´¥</div>';
                }
            } catch (error) {
                console.error('åŠ è½½æ–‡ä»¶åˆ—è¡¨å¤±è´¥:', error);
                fileList.innerHTML = '<div style="color: red;">åŠ è½½å‡ºé”™</div>';
            }
        }

        // æ¸²æŸ“æ–‡ä»¶åˆ—è¡¨
        function renderFileList(files) {
            if (!files || files.length === 0) {
                fileList.innerHTML = '<div style="color: #999;">æš‚æ— æ–‡ä»¶</div>';
                return;
            }

            let html = '<ul style="list-style: none; padding: 0;">';
            files.forEach(file => {
                const date = new Date(file.mtime * 1000).toLocaleString();
                const size = (file.size / 1024).toFixed(1) + ' KB';
                const fileType = file.file_type || 'document'; // å‘åå…¼å®¹ï¼Œé»˜è®¤ä¸º document
                const typeIcon = fileType === 'image' ? 'ğŸ–¼ï¸' : 'ğŸ“„';
                const typeLabel = fileType === 'image' ? 'å›¾ç‰‡' : 'æ–‡æ¡£';
                // è½¬ä¹‰æ–‡ä»¶åä¸­çš„å•å¼•å·ï¼Œé¿å… onclick ä¸­çš„å¼•å·å†²çª
                const safeFilename = file.name.replace(/'/g, "\\'");
                html += `
                    <li style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #f0f0f0;">
                        <div>
                            <div style="font-weight: 500; color: #333;">${typeIcon} ${file.name} <span style="font-size: 0.8em; color: #999; font-weight: normal;">(${typeLabel})</span></div>
                            <div style="font-size: 0.8em; color: #999;">${date} Â· ${size}</div>
                        </div>
                        <button onclick="deleteFile('${safeFilename}', '${fileType}')" style="padding: 5px 10px; font-size: 12px; background: #ff5252; color: white; border: none; border-radius: 5px; cursor: pointer;">åˆ é™¤</button>
                    </li>
                `;
            });
            html += '</ul>';
            fileList.innerHTML = html;
        }

        // åˆ é™¤æ–‡ä»¶
        window.deleteFile = async function(filename, fileType) {
            if (!fileType) {
                alert('é”™è¯¯ï¼šæ— æ³•ç¡®å®šæ–‡ä»¶ç±»å‹ï¼Œè¯·åˆ·æ–°é¡µé¢åé‡è¯•');
                return;
            }
            
            const fileTypeLabel = fileType === 'image' ? 'å›¾ç‰‡' : 'æ–‡æ¡£';
            if (!confirm(`ç¡®å®šè¦åˆ é™¤${fileTypeLabel} "${filename}" å—ï¼Ÿè¿™å°†é‡å»ºçŸ¥è¯†åº“ï¼Œå¯èƒ½éœ€è¦ä¸€ç‚¹æ—¶é—´ã€‚`)) {
                return;
            }

            try {
                // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
                const btn = document.createElement('button');
                btn.textContent = 'åˆ é™¤ä¸­...';
                btn.disabled = true;
                btn.style.padding = '5px 10px';
                btn.style.fontSize = '12px';
                btn.style.background = '#ff5252';
                btn.style.color = 'white';
                btn.style.border = 'none';
                btn.style.borderRadius = '5px';
                btn.style.cursor = 'pointer';

                const response = await fetch('/api/files', {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        filename: filename,
                        file_type: fileType
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    await loadFiles();
                    showError('æ–‡ä»¶å·²åˆ é™¤ï¼ŒçŸ¥è¯†åº“å·²æ›´æ–°');
                } else {
                    alert('åˆ é™¤å¤±è´¥: ' + (data.error || 'æœªçŸ¥é”™è¯¯'));
                    btn.textContent = originalText;
                    btn.disabled = false;
                }
            } catch (error) {
                console.error('åˆ é™¤æ–‡ä»¶å¤±è´¥:', error);
                alert('åˆ é™¤å‡ºé”™: ' + error.message);
                btn.textContent = 'åˆ é™¤';
                btn.disabled = false;
            }
        };

        // åŠ è½½çƒ­è¯é…ç½®
        async function loadHotwords() {
            try {
                const response = await fetch('/api/hotwords');
                const data = await response.json();
                if (data.hotwords) {
                    document.getElementById('hotwordsInput').value = data.hotwords;
                }
            } catch (error) {
                console.error('åŠ è½½çƒ­è¯å¤±è´¥:', error);
            }
        }

        // ä¿å­˜çƒ­è¯é…ç½®
        async function saveHotwords() {
            const hotwords = document.getElementById('hotwordsInput').value;
            try {
                await fetch('/api/hotwords', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ hotwords: hotwords })
                });
            } catch (error) {
                console.error('ä¿å­˜çƒ­è¯å¤±è´¥:', error);
            }
        }

        // ç›‘å¬çƒ­è¯è¾“å…¥æ¡†å˜åŒ–
        document.getElementById('hotwordsInput').addEventListener('blur', saveHotwords);

        // é¡µé¢åŠ è½½æ—¶è·å–æ–‡ä»¶åˆ—è¡¨
        loadFiles();
        loadHotwords();

        // å›¾ç‰‡é€‰æ‹©/é¢„è§ˆ
        btnImage.addEventListener('click', () => imageInput.click());

        imageInput.addEventListener('change', () => {
            const file = imageInput.files && imageInput.files[0];
            if (!file) {
                clearImageSelection();
                return;
            }

            const allowed = ['image/jpeg', 'image/png', 'image/webp'];
            const extOk = allowed.includes(file.type) || /\.(jpg|jpeg|png|webp)$/i.test(file.name);
            if (!extOk) {
                showError('ä»…æ”¯æŒ jpg/jpeg/png/webp å›¾ç‰‡');
                clearImageSelection();
                return;
            }
            if (file.size > MAX_IMAGE_SIZE) {
                showError('å›¾ç‰‡å¤§å°è¶…å‡º 2MB é™åˆ¶');
                clearImageSelection();
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                imageThumb.src = e.target.result;
                imageName.textContent = file.name;
                imageSize.textContent = `${(file.size / 1024).toFixed(1)} KB`;
                imagePreview.classList.remove('hidden');
            };
            reader.readAsDataURL(file);
        });

        btnClearImage.addEventListener('click', () => {
            clearImageSelection();
        });

        function clearImageSelection() {
            imageInput.value = '';
            imageThumb.src = '';
            imageName.textContent = '';
            imageSize.textContent = '';
            imagePreview.classList.add('hidden');
        }

        // å‘é€æ–‡æœ¬
        async function sendText() {
            const text = textInput.value.trim();
            const imageFile = imageInput.files && imageInput.files[0];
            
            // åªæœ‰æ–‡å­—å’Œå›¾ç‰‡éƒ½ä¸ºç©ºæ—¶æ‰é˜»æ­¢å‘é€
            if (!text && !imageFile) return;

            if (imageFile) {
                const allowed = ['image/jpeg', 'image/png', 'image/webp'];
                const extOk = allowed.includes(imageFile.type) || /\.(jpg|jpeg|png|webp)$/i.test(imageFile.name);
                if (!extOk) {
                    showError('ä»…æ”¯æŒ jpg/jpeg/png/webp å›¾ç‰‡');
                    return;
                }
                if (imageFile.size > MAX_IMAGE_SIZE) {
                    showError('å›¾ç‰‡å¤§å°è¶…å‡º 2MB é™åˆ¶');
                    return;
                }
            }

            try {
                updateUI('processing');
                textInput.disabled = true;
                btnSend.disabled = true;
                btnImage.disabled = true;

                let response;
                if (imageFile) {
                    const formData = new FormData();
                    formData.append('text', text || '');  // å…è®¸ç©ºå­—ç¬¦ä¸²
                    if (lastAudioId) {
                        formData.append('audio_id', lastAudioId);
                    }
                    formData.append('image', imageFile);
                    response = await fetch('/api/query', {
                        method: 'POST',
                        body: formData
                    });
                } else {
                    response = await fetch('/api/query', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ 
                            text: text,
                            audio_id: lastAudioId  // ä¼ é€’ audio_id
                        })
                    });
                }

                const data = await response.json();

                if (data.success) {
                    // åˆå¹¶ ASR è€—æ—¶ï¼ˆå¦‚æœæœ‰ï¼‰
                    const timings = data.timings || {};
                    if (lastAsrTime > 0) {
                        timings.asr_time = lastAsrTime;
                        // é‡æ–°è®¡ç®—æ€»è€—æ—¶ï¼ˆè¿‘ä¼¼ï¼‰
                        if (timings.total_time) {
                            timings.total_time += lastAsrTime;
                        }
                        lastAsrTime = 0; // é‡ç½®
                    }
                    
                    displayResult(data.recognized_text, data.answer, data.audio, timings, data.sources, data.audio_id);
                    textInput.value = ''; // æ¸…ç©ºè¾“å…¥æ¡†
                    lastAudioId = null; // é‡ç½® audio_id
                    recognitionResult.style.display = 'none'; // éšè—è¯†åˆ«ç»“æœåŒºåŸŸ
                    clearImageSelection();
                } else {
                    showError(data.error || 'å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•');
                }
            } catch (error) {
                console.error('å‘é€æ–‡æœ¬å¤±è´¥:', error);
                showError('å‘é€æ–‡æœ¬æ—¶å‡ºé”™: ' + error.message);
            } finally {
                updateUI('idle');
                textInput.disabled = false;
                btnSend.disabled = false;
                btnImage.disabled = false;
                textInput.focus();
            }
        }

        btnSend.addEventListener('click', sendText);
        textInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendText();
            }
        });

        // çŠ¶æ€å˜é‡
        let isEditing = false;

        // è¿›å…¥ç¼–è¾‘æ¨¡å¼
        function enterEditMode() {
            if (isEditing) return;
            isEditing = true;

            // è½¬æ¢ä¸ºå¯ç¼–è¾‘çš„textarea
            const textarea = document.createElement('textarea');
            textarea.value = lastRecognizedText;
            textarea.style.width = '100%';
            textarea.style.minHeight = '80px';
            textarea.style.padding = '10px';
            textarea.style.fontSize = '1.1em';
            textarea.style.border = '2px solid #FF9800';
            textarea.style.borderRadius = '5px';
            textarea.style.fontFamily = 'inherit';
            textarea.style.resize = 'vertical';
            textarea.id = 'correctionTextarea';
            
            recognizedTextDiv.replaceWith(textarea);
            textarea.focus();
            textarea.select();
            
            // æ›´æ–°æŒ‰é’®
            btnCorrect.textContent = 'âœ“ æäº¤ä¿®æ­£';
            btnCorrect.style.background = '#4CAF50';
            btnCorrect.onclick = submitCorrection;
            
            btnAccept.textContent = 'âœ— å–æ¶ˆ';
            btnAccept.style.background = '#f44336';
            btnAccept.onclick = cancelEdit;
        }

        // æäº¤çº é”™
        async function submitCorrection() {
            const textarea = document.getElementById('correctionTextarea');
            if (!textarea) return;

            const correctedText = textarea.value.trim();
            
            if (!correctedText) {
                alert('ä¿®æ­£æ–‡æœ¬ä¸èƒ½ä¸ºç©º');
                return;
            }
            
            if (correctedText === lastRecognizedText) {
                cancelEdit();
                return;
            }
            
            try {
                // ä¿å­˜è¯†åˆ«æ•°æ®ï¼ˆå¸¦çº é”™æ–‡æœ¬ï¼‰
                await saveRecognitionData(lastRecognizedText, correctedText);
                
                // æ›´æ–°è¾“å…¥æ¡†ä¸ºä¿®æ­£åçš„æ–‡æœ¬
                textInput.value = correctedText;
                
                // éšè—è¯†åˆ«ç»“æœåŒºåŸŸ
                recognitionResult.style.display = 'none';
                
                // èšç„¦åˆ°è¾“å…¥æ¡†
                textInput.focus();

                // æ¢å¤ç•Œé¢çŠ¶æ€
                resetInterface(correctedText);
                
            } catch (error) {
                console.error('æäº¤çº é”™å¤±è´¥:', error);
                alert('æäº¤å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
            }
        }

        // å–æ¶ˆç¼–è¾‘
        function cancelEdit() {
            resetInterface(lastRecognizedText);
        }

        // æ¢å¤ç•Œé¢çŠ¶æ€
        function resetInterface(textToShow) {
            const textarea = document.getElementById('correctionTextarea');
            const textDiv = document.createElement('div');
            textDiv.id = 'recognizedText';
            textDiv.style.cssText = 'font-size: 1.1em; line-height: 1.6; margin-bottom: 10px; min-height: 30px;';
            textDiv.textContent = textToShow;
            
            if (textarea) {
                textarea.replaceWith(textDiv);
            } else if (recognizedTextDiv && recognizedTextDiv.parentNode) {
                recognizedTextDiv.replaceWith(textDiv);
            }
            
            recognizedTextDiv = textDiv; // æ›´æ–°å¼•ç”¨
            isEditing = false;
            
            // æ¢å¤æŒ‰é’®
            btnCorrect.textContent = 'âœï¸ è¯†åˆ«æœ‰è¯¯ï¼Œç‚¹å‡»çº é”™';
            btnCorrect.style.background = '';
            btnCorrect.onclick = enterEditMode;
            
            btnAccept.textContent = 'âœ“ è¯†åˆ«æ­£ç¡®';
            btnAccept.style.background = '#4CAF50';
            btnAccept.onclick = acceptRecognition;
        }

        // ä¿å­˜è¯†åˆ«æ•°æ®åˆ°åç«¯
        async function saveRecognitionData(recognizedText, correctedText = null) {
            try {
                const response = await fetch('/api/save_recognition', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        audio_base64: lastAudioBase64,
                        recognized_text: recognizedText,
                        corrected_text: correctedText,
                        confidence: lastConfidence
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    console.log('è¯†åˆ«æ•°æ®å·²ä¿å­˜:', data.audio_id);
                    lastAudioId = data.audio_id; // æ›´æ–°ä¸ºçœŸå®çš„ audio_id
                } else {
                    console.error('ä¿å­˜è¯†åˆ«æ•°æ®å¤±è´¥:', data.error);
                }
            } catch (error) {
                console.error('ä¿å­˜è¯†åˆ«æ•°æ®æ—¶å‡ºé”™:', error);
            }
        }
        
        // æ¥å—è¯†åˆ«ç»“æœ
        async function acceptRecognition() {
            // ä¿å­˜è¯†åˆ«æ•°æ®ï¼ˆè¯†åˆ«æ­£ç¡®ï¼Œæ— çº é”™ï¼‰
            await saveRecognitionData(lastRecognizedText, null);
            
            // éšè—è¯†åˆ«ç»“æœåŒºåŸŸ
            recognitionResult.style.display = 'none';
            // èšç„¦åˆ°è¾“å…¥æ¡†
            textInput.focus();
        }
        
        // åˆå§‹ç»‘å®š
        btnCorrect.onclick = enterEditMode;
        btnAccept.onclick = acceptRecognition;

        // æ¸…ç©ºè®°å½•
        btnClear.addEventListener('click', () => {
            results.innerHTML = '';
            lastAudioId = null; // æ¸…ç©ºå†å²è®°å½•æ—¶ä¹Ÿé‡ç½® audio_id
            recognitionResult.style.display = 'none'; // éšè—è¯†åˆ«ç»“æœåŒºåŸŸ
        });

        // ä¸Šä¼ çŸ¥è¯†åº“æ–‡ä»¶
        btnUpload.addEventListener('click', async () => {
            if (!fileInput.files || fileInput.files.length === 0) {
                showError('è¯·å…ˆé€‰æ‹©è¦ä¸Šä¼ çš„æ–‡ä»¶');
                return;
            }
            const file = fileInput.files[0];
            const formData = new FormData();
            formData.append('file', file);
            uploadStatus.textContent = 'æ­£åœ¨ä¸Šä¼ å¹¶å‘é‡åŒ–...';

            try {
                const resp = await fetch('/api/upload_kb', {
                    method: 'POST',
                    body: formData
                });
                const data = await resp.json();
                if (data.success) {
                    uploadStatus.textContent = `ä¸Šä¼ æˆåŠŸï¼š${file.name}ã€‚å·²æ·»åŠ åˆ°çŸ¥è¯†åº“ã€‚`;
                    loadFiles(); // åˆ·æ–°åˆ—è¡¨
                } else {
                    uploadStatus.textContent = `ä¸Šä¼ å¤±è´¥ï¼š${data.error || 'æœªçŸ¥é”™è¯¯'}`;
                }
            } catch (e) {
                uploadStatus.textContent = `ä¸Šä¼ å¤±è´¥ï¼š${e.message}`;
            }
        });

        // è·å–çƒ­è¯é…ç½®
        function getHotwords() {
            const input = document.getElementById('hotwordsInput').value.trim();
            if (!input) return '';
            
            const lines = input.split('\n');
            const words = [];
            
            for (const line of lines) {
                let part = line.trim();
                if (!part) continue;
                
                // å°è¯•åˆ†ç¦»æƒé‡ï¼ˆå¦‚æœæœ‰ï¼‰ï¼Œä½†ç›®å‰åªä½¿ç”¨è¯æœ¬èº«ï¼Œå› ä¸º JSON æ ¼å¼å¯èƒ½ä¸è¢«æ”¯æŒ
                // å‡è®¾æ ¼å¼æ˜¯ "è¯è¯­ æƒé‡" æˆ– "è¯è¯­"
                const parts = part.split(/\s+/);
                if (parts.length > 1) {
                    const lastPart = parts[parts.length - 1];
                    if (!isNaN(parseInt(lastPart))) {
                        // æœ€åä¸€ä¸ªæ˜¯æ•°å­—ï¼Œè®¤ä¸ºæ˜¯æƒé‡ï¼Œå»æ‰å®ƒ
                        part = parts.slice(0, parts.length - 1).join(' ');
                    }
                }
                if (part) words.push(part);
            }
            
            // è¿”å›ç©ºæ ¼åˆ†éš”çš„å­—ç¬¦ä¸²ï¼Œè€Œä¸æ˜¯ JSON
            return words.join(' ');
        }

        // å¤„ç†éŸ³é¢‘
        async function processAudio() {
            try {
                updateUI('processing');
                
                // å°†éŸ³é¢‘è½¬æ¢ä¸º WAV æ ¼å¼
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                const wavBlob = await convertToWav(audioBlob);
                
                // å‘é€åˆ°æœåŠ¡å™¨
                const formData = new FormData();
                formData.append('audio', wavBlob, 'recording.wav');
                
                // æ·»åŠ çƒ­è¯
                const hotwords = getHotwords();
                if (hotwords) {
                    formData.append('hotwords', hotwords);
                }
                
                // æ”¹ä¸ºåªè°ƒç”¨è¯†åˆ«æ¥å£
                const response = await fetch('/api/recognize', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // ä¿å­˜è¯†åˆ«ç»“æœï¼ˆä¸ç«‹å³ä¿å­˜æ•°æ®ï¼Œç­‰å¾…ç”¨æˆ·ç¡®è®¤ï¼‰
                    lastRecognizedText = data.text;
                    lastAudioId = data.temp_id || data.audio_id; // ä½¿ç”¨ä¸´æ—¶ID
                    lastConfidence = data.confidence || 0;
                    lastAudioBase64 = data.audio_base64; // å­˜å‚¨éŸ³é¢‘æ•°æ®
                    
                    // ä¿å­˜ ASR è€—æ—¶
                    if (data.timings && data.timings.asr_time) {
                        lastAsrTime = data.timings.asr_time;
                    }
                    
                    // æ˜¾ç¤ºè¯†åˆ«ç»“æœåŒºåŸŸ
                    recognizedTextDiv.textContent = data.text;
                    recognitionMeta.innerHTML = `
                        <span>è€—æ—¶: ${data.timings.asr_time.toFixed(2)}s</span>
                        ${data.confidence > 0 ? ` | <span>ç½®ä¿¡åº¦: ${(data.confidence * 100).toFixed(1)}%</span>` : ''}
                        ${data.audio_id ? ` | <span style="font-size: 0.8em; color: #999;">ID: ${data.audio_id}</span>` : ''}
                    `;
                    recognitionResult.style.display = 'block';
                    
                    // åŒæ—¶å¡«å…¥è¾“å…¥æ¡†
                    textInput.value = data.text;
                    
                    updateUI('idle');
                    
                    // æç¤ºç”¨æˆ·
                    const statusDiv = document.getElementById('status');
                    statusDiv.textContent = 'è¯†åˆ«å®Œæˆï¼Œè¯·ç¡®è®¤è¯†åˆ«ç»“æœ';
                    setTimeout(() => {
                        if (statusDiv.textContent === 'è¯†åˆ«å®Œæˆï¼Œè¯·ç¡®è®¤è¯†åˆ«ç»“æœ') {
                            statusDiv.textContent = 'å‡†å¤‡å°±ç»ª';
                        }
                    }, 3000);
                    
                } else {
                    showError(data.error || 'è¯†åˆ«å¤±è´¥ï¼Œè¯·é‡è¯•');
                    updateUI('idle');
                }
                
            } catch (error) {
                console.error('å¤„ç†éŸ³é¢‘å¤±è´¥:', error);
                showError('å¤„ç†éŸ³é¢‘æ—¶å‡ºé”™: ' + error.message);
                updateUI('idle');
            }
        }

        // å°†éŸ³é¢‘è½¬æ¢ä¸º WAV æ ¼å¼
        async function convertToWav(audioBlob) {
            return new Promise(async (resolve, reject) => {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const arrayBuffer = await audioBlob.arrayBuffer();
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    
                    // è½¬æ¢ä¸º 16kHz å•å£°é“
                    const targetSampleRate = 16000;
                    const offlineContext = new OfflineAudioContext(
                        1, 
                        Math.ceil(audioBuffer.duration * targetSampleRate), 
                        targetSampleRate
                    );
                    const source = offlineContext.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(offlineContext.destination);
                    source.start();
                    
                    const resampledBuffer = await offlineContext.startRendering();
                    
                    // è½¬æ¢ä¸º WAV
                    const wav = audioBufferToWav(resampledBuffer);
                    const wavBlob = new Blob([wav], { type: 'audio/wav' });
                    resolve(wavBlob);
                } catch (error) {
                    console.error('éŸ³é¢‘è½¬æ¢å¤±è´¥:', error);
                    reject(error);
                }
            });
        }

        // AudioBuffer è½¬ WAV
        function audioBufferToWav(buffer) {
            const length = buffer.length;
            const arrayBuffer = new ArrayBuffer(44 + length * 2);
            const view = new DataView(arrayBuffer);
            const samples = buffer.getChannelData(0);
            
            // WAV æ–‡ä»¶å¤´
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + length * 2, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);  // PCM
            view.setUint16(22, 1, true);  // å•å£°é“
            view.setUint32(24, buffer.sampleRate, true);
            view.setUint32(28, buffer.sampleRate * 2, true);
            view.setUint16(32, 2, true);  // å­—èŠ‚å¯¹é½
            view.setUint16(34, 16, true); // ä½æ·±åº¦
            writeString(36, 'data');
            view.setUint32(40, length * 2, true);
            
            // å†™å…¥ PCM æ•°æ®
            let offset = 44;
            for (let i = 0; i < length; i++) {
                const sample = Math.max(-1, Math.min(1, samples[i]));
                view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                offset += 2;
            }
            
            return arrayBuffer;
        }

        // æ›´æ–° UI çŠ¶æ€
        let currentUIState = 'idle'; // è®°å½•å½“å‰UIçŠ¶æ€
        function updateUI(state) {
            const previousState = currentUIState;
            currentUIState = state;
            status.className = `status ${state}`;
            switch(state) {
                case 'idle':
                    // å¦‚æœå·²å¯ç”¨ç›‘å¬ï¼Œæ˜¾ç¤ºå”¤é†’è¯ï¼›å¦åˆ™æ˜¾ç¤º"å‡†å¤‡å°±ç»ª"
                    status.textContent = micEnabled ? `å”¤é†’è¯ï¼š${WAKE_WORD}` : 'å‡†å¤‡å°±ç»ª';
                    waveform.classList.add('hidden');
                    // å¦‚æœä¹‹å‰æ˜¯å¤„ç†çŠ¶æ€ï¼Œä¸”éº¦å…‹é£å·²å¯ç”¨ï¼Œä¸”æœªå”¤é†’ï¼Œæ¢å¤å”¤é†’è¯ç›‘å¬
                    if (previousState === 'processing' && micEnabled && ws && ws.readyState === 1 && !hasWoken) {
                        // å¦‚æœä¹‹å‰æœªå”¤é†’ï¼Œæ¢å¤å”¤é†’è¯ç›‘å¬
                        sendCtrl({ wake_word: WAKE_WORD });
                        sendCtrl({ wake_word_enabled: true, is_speaking: true });
                    }
                    break;
                case 'recording':
                    status.textContent = 'æ­£åœ¨å½•éŸ³...';
                    waveform.classList.remove('hidden');
                    // å¦‚æœä¹‹å‰æ˜¯å¤„ç†çŠ¶æ€ï¼Œä¸”å·²ç»å”¤é†’ï¼Œæ¢å¤è¯­éŸ³è¾“å…¥ï¼ˆä½†ä¸é‡æ–°å¼€å¯å”¤é†’è¯ï¼Œå› ä¸ºå·²ç»å”¤é†’äº†ï¼‰
                    if (previousState === 'processing' && micEnabled && ws && ws.readyState === 1 && hasWoken) {
                        // å·²ç»å”¤é†’çŠ¶æ€ï¼Œåªéœ€è¦æ¢å¤is_speakingï¼Œä¸éœ€è¦é‡æ–°å¼€å¯å”¤é†’è¯ç›‘å¬
                        sendCtrl({ is_speaking: true });
                    }
                    break;
                case 'processing':
                    status.textContent = 'æ­£åœ¨å¤„ç†';
                    waveform.classList.add('hidden');
                    // å¤„ç†çŠ¶æ€æ—¶ï¼Œç¦ç”¨è¯­éŸ³è¾“å…¥ï¼ˆå…³é—­å”¤é†’è¯ç›‘å¬ï¼‰
                    if (micEnabled && ws && ws.readyState === 1) {
                        sendCtrl({ wake_word_enabled: false, is_speaking: false });
                    }
                    break;
            }
        }

        // æ˜¾ç¤ºç»“æœ
        function displayResult(recognizedText, answer, audioData, timings, sources, audioId) {
            const resultDiv = document.createElement('div');

            // å¦‚æœæœ‰ä¸Šä¸€æ¬¡AIè¯­éŸ³æ­£åœ¨æ’­æ”¾ï¼Œå…ˆåœæ­¢å®ƒï¼Œé¿å…å¤šè·¯æ’­æ”¾
            if (window._currentTtsAudio) {
                try { window._currentTtsAudio.pause(); } catch(_){}
                try { window._currentTtsAudio.currentTime = 0; } catch(_){}
                stopAssistantEq && stopAssistantEq();
                window._currentTtsAudio = null;
            }
            
            let audioHTML = '';
            if (audioData) {
                audioHTML = `
                    <div style="margin-top: 15px;">
                        <audio controls style="width: 100%; max-width: 500px;">
                            <source src="${audioData}" type="audio/wav">
                            æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘æ’­æ”¾ã€‚
                            </audio>
                    </div>
                `;
            }

            let timingsHTML = '';
            if (timings) {
                timingsHTML = '<div style="margin-top: 10px; font-size: 0.85em; color: #666; border-top: 1px solid #eee; padding-top: 10px;">';
                if (timings.asr_time) timingsHTML += `<span>ASR: ${timings.asr_time.toFixed(2)}s</span> | `;
                if (timings.rag_time) {
                    timingsHTML += `<span>RAG: ${timings.rag_time.toFixed(2)}s`;
                    if (timings.retrieval && timings.llm_generation) {
                        timingsHTML += ` (æ£€ç´¢: ${timings.retrieval.toFixed(2)}s, ç”Ÿæˆ: ${timings.llm_generation.toFixed(2)}s)`;
                    }
                    timingsHTML += `</span> | `;
                }
                if (timings.tts_time) timingsHTML += `<span>TTS: ${timings.tts_time.toFixed(2)}s</span> | `;
                if (timings.total_time) timingsHTML += `<span>Total: ${timings.total_time.toFixed(2)}s</span>`;
                timingsHTML += '</div>';
            }

            let sourcesHTML = '';
            if (sources && sources.length > 0) {
                sourcesHTML = `
                    <div style="margin-top: 15px; border-top: 1px solid #eee; padding-top: 10px;">
                        <details>
                            <summary style="cursor: pointer; color: #666; font-size: 0.9em; user-select: none;">
                                ğŸ“š å‚è€ƒå¼•ç”¨ (${sources.length})
                            </summary>
                            <div style="margin-top: 10px; font-size: 0.9em; color: #555; background: #fff; padding: 10px; border-radius: 5px; border: 1px solid #eee;">
                                ${sources.map((s, i) => `
                                    <div style="margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px dashed #eee;">
                                        <div style="font-weight: bold; color: #333; margin-bottom: 5px;">[${i+1}] ${s.source}</div>
                                        <div style="line-height: 1.5;">${s.content}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </details>
                    </div>
                `;
            }
            
            resultDiv.innerHTML = `
                <div class="result-section">
                    <h3>ç”¨æˆ·é—®é¢˜</h3>
                    <div class="result-text">${recognizedText}</div>
                </div>
                <div class="result-section answer">
                    <h3>AI å›ç­”</h3>
                    <div class="result-text">${answer}</div>
                    ${sourcesHTML}
                    ${audioHTML}
                    ${timingsHTML}
                </div>
            `;
            results.insertBefore(resultDiv, results.firstChild);
            
            // è‡ªåŠ¨æ’­æ”¾éŸ³é¢‘ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            if (audioData) {
                const audio = resultDiv.querySelector('audio');
                if (audio) {
                    // è®°å½•å½“å‰TTSéŸ³é¢‘ï¼Œç¡®ä¿æ–°å›ç­”åˆ°æ¥æ—¶èƒ½å…³é—­ä¸Šä¸€ä¸ª
                    window._currentTtsAudio = audio;
                    // ç»‘å®š AI è¯´è¯åŠ¨æ•ˆåŠå›å£°æ¶ˆé™¤æ ‡å¿—
                    audio.addEventListener('play', () => {
                        startAssistantEq();
                        window._isAiSpeaking = true; // æ ‡è®° AI æ­£åœ¨è¯´è¯
                    });
                    audio.addEventListener('ended', () => { 
                        stopAssistantEq(); 
                        window._isAiSpeaking = false; // æ ‡è®° AI è¯´è¯ç»“æŸ
                        if (window._currentTtsAudio===audio) window._currentTtsAudio=null; 
                    });
                    audio.addEventListener('pause', () => { 
                        stopAssistantEq(); 
                        window._isAiSpeaking = false; // æ ‡è®° AI è¯´è¯æš‚åœ
                        if (window._currentTtsAudio===audio) window._currentTtsAudio=null; 
                    });
                    audio.play().catch(e => {
                        console.log('è‡ªåŠ¨æ’­æ”¾è¢«é˜»æ­¢ï¼Œç”¨æˆ·éœ€è¦æ‰‹åŠ¨ç‚¹å‡»æ’­æ”¾');
                    });
                }
            }
        }
        
        // æ˜¾ç¤ºé”™è¯¯
        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = 'âŒ ' + message;
            results.insertBefore(errorDiv, results.firstChild);
            
            setTimeout(() => {
                errorDiv.remove();
            }, 5000);
        }
        // ===== å”¤é†’è¯ + WebSocket å®æ—¶æµ =====
        let ws = null;
        let wsConnected = false;
        let wsInitSent = false;
        let wsAutoReconnect = false;
        let wsResetting = false; // é‡å¯WSè¿‡ç¨‹ä¸­ï¼ŒæŠ‘åˆ¶â€œè¿æ¥å·²å…³é—­â€ç­‰çŠ¶æ€æç¤º
        let audioCtx = null;
        let processor = null;
        let micStream = null;
        // å¾…å‘é€çš„ PCM16 ç¼“å†²ï¼ŒæŒ‰ 960 é‡‡æ ·ä¸€åŒ…åˆ‡ç‰‡ï¼ˆä¸å®˜æ–¹ demo ä¿æŒä¸€è‡´ï¼‰
        let pendingPCM = new Int16Array(0);

        let wakeBypassed = false;  // æ˜¯å¦è·³è¿‡å”¤é†’è¯
        let sentChunks = 0;        // å·²å‘é€çš„éŸ³é¢‘åŒ…è®¡æ•°
        let micEnabled = false;    // æ˜¯å¦å·²å¯ç”¨ç›‘å¬
        let silenceAccumMs = 0;    // è¿ç»­é™éŸ³ç´¯è®¡æ—¶é•¿(ms)
        let hasWoken = false;      // æœ¬è½®æ˜¯å¦å·²è¢«å”¤é†’ï¼ˆä»…å”¤é†’åæ‰è§¦å‘é™éŸ³å›é€€ï¼‰
        let silenceGuardUntil = 0; // å”¤é†’åçš„é™éŸ³ä¿æŠ¤æœŸï¼ˆæ¯«ç§’æ—¶é—´æˆ³ï¼‰
        window.isPlayingWakeSound = false; // æ˜¯å¦æ­£åœ¨æ’­æ”¾å”¤é†’æç¤ºéŸ³

        const WAKE_WORD = 'ä¹Œè¨å¥‡'; // å”¤é†’è¯ï¼ˆç¡¬ç¼–ç ï¼‰

        const btnWakeBypass = document.getElementById('btnWakeBypass');
// åˆå§‹éšè—â€œè·³è¿‡å”¤é†’è¯â€æŒ‰é’®ï¼Œå¯ç”¨ç›‘å¬åå†æ˜¾ç¤º
if (btnWakeBypass) btnWakeBypass.style.display = 'none';
let autoSendTimer = null;
let autoSendInFlight = false;
let lastPartialText = '';

// å°†è¯†åˆ«å‡ºçš„è¯­éŸ³æ–‡æœ¬ç›´æ¥å‘é€ç»™å¤§æ¨¡å‹ï¼ˆè·³è¿‡è¾“å…¥æ¡†ï¼‰
async function sendRecognizedToLLM(text) {
    const payload = { text: text, audio_id: null };
    try {
        updateUI('processing');
        const resp = await fetch('/api/text_chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        const data = await resp.json();
        if (data && data.success) {
            displayResult(text, data.answer, data.audio, data.timings, data.sources, data.audio_id);
        } else {
            showError(data && data.error ? data.error : 'å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•');
        }
    } catch (e) {
        showError('å‘é€è¯†åˆ«æ–‡æœ¬æ—¶å‡ºé”™: ' + e.message);
    } finally {
        updateUI(micEnabled && hasWoken ? 'recording' : 'idle');
    }
}

        const btnWakeEnableMic = document.getElementById('btnWakeEnableMic');
        const wakeStatus = document.getElementById('wakeStatus');
        const SILENCE_TIMEOUT_MS = 15000; // è¿ç»­é™éŸ³è¶…æ—¶è‡ªåŠ¨å›åˆ°å”¤é†’
        const SILENCE_ABS_THRESH = 400;   // Int16 å¹³å‡ç»å¯¹å¹…åº¦é˜ˆå€¼ï¼ˆç»éªŒå€¼ï¼‰
        const SILENCE_GUARD_MS = 1500;    // å”¤é†’åçš„é™éŸ³ä¿æŠ¤æ—¶é•¿ï¼ˆé¿å…ä¸€å”¤é†’å°±è¢«è¯¯åˆ¤é™éŸ³ï¼‰

        function wsUrl() {
            const scheme = location.protocol === 'https:' ? 'wss://' : 'ws://';
            // é»˜è®¤åç«¯ç«¯å£ 10095
            return scheme + location.hostname + ':10095';
        }

        function setWakeStatus(text) {
            wakeStatus.textContent = text;
        }



        function sendCtrl(obj) {
            if (ws && ws.readyState === 1) {
                ws.send(JSON.stringify(obj));
            }
        }

        function waitWsOpen(timeoutMs=4000){
            return new Promise(resolve=>{
                const start=Date.now();
                const timer=setInterval(()=>{
                    if(ws && ws.readyState===1){ clearInterval(timer); resolve(true); }
                    else if(Date.now()-start>timeoutMs){ clearInterval(timer); resolve(false); }
                },100);
            });
        }

        function initWebSocket() {
            if (ws && (ws.readyState === 0 || ws.readyState === 1)) return; // æ­£åœ¨è¿æˆ–å·²è¿
            ws = new WebSocket(wsUrl(), 'binary');
            // ä¸å®˜æ–¹ demo ä¸€è‡´ï¼Œå¼ºåˆ¶ä»¥ ArrayBuffer å¤„ç†äºŒè¿›åˆ¶
            ws.binaryType = 'arraybuffer';

            ws.onopen = async () => {
                wsConnected = true;
                setWakeStatus('å·²è¿æ¥åç«¯ï¼Œè¯·ç‚¹å‡»â€œå¯ç”¨ç›‘å¬â€å¼€å§‹å”¤é†’è¯ç›‘å¬');
                // å‘é€åˆå§‹æ§åˆ¶é…ç½®ï¼ˆåˆå¹¶å…³é”®å‚æ•°ï¼Œé¿å…åç«¯å–ä¸åˆ°ï¼‰
                const initMsg = {
                    mode: '2pass',
                    chunk_size: [5, 10, 5],
                    encoder_chunk_look_back: 4,
                    decoder_chunk_look_back: 1,
                    is_speaking: true,
                    chunk_interval: 10,
                    wav_name: 'web',
                    wake_word: WAKE_WORD,
                    wake_word_enabled: false,
                };
                const hotwords = getHotwords();
                if (hotwords) initMsg.hotwords = hotwords;
                sendCtrl(initMsg);
            };

            ws.onmessage = (ev) => {
                if (typeof ev.data === 'string') {
                    try {
                        const msg = JSON.parse(ev.data);
                        if (msg.event === 'wake_listening') {
                            setWakeStatus(`ç›‘å¬ä¸­ï¼š${msg.wake_word || WAKE_WORD}`);
                            if (btnWakeBypass) btnWakeBypass.style.display = 'inline-block';
                            updateUI('idle');
                            // å›åˆ°ç­‰å¾…å”¤é†’çŠ¶æ€
                            hasWoken = false;
                        } else if (msg.event === 'wake_word_detected') {
                            // å¦‚æœæ­£åœ¨å¤„ç†ï¼Œå¿½ç•¥å”¤é†’è¯
                            if (status.className.includes('processing')) {
                                console.log('æ­£åœ¨å¤„ç†ä¸­ï¼Œå¿½ç•¥å”¤é†’è¯');
                                return;
                            }

                            // æš‚æ—¶å±è”½å½•éŸ³
                            window.isPlayingWakeSound = true;
                            setWakeStatus('å·²å”¤é†’ï¼Œæ­£åœ¨å›åº”...');

                            // æ’­æ”¾æç¤ºéŸ³
                            const audio = new Audio('/static/here.mp3');
                            
                            const startRecording = () => {
                                window.isPlayingWakeSound = false;
                                setWakeStatus('å·²å”¤é†’ï¼Œå¼€å§‹è¯†åˆ«...');
                                if (btnWakeBypass) btnWakeBypass.style.display = 'none';
                                updateUI('recording');
                                // ç”¨æˆ·è¯´è¯é˜¶æ®µï¼šå¼€å¯å½•éŸ³åŠ¨æ•ˆ
                                hasWoken = true;
                                silenceAccumMs = 0;
                                silenceGuardUntil = Date.now() + SILENCE_GUARD_MS;
                            };

                            audio.onended = startRecording;
                            audio.onerror = (e) => {
                                console.error("æ’­æ”¾å”¤é†’æç¤ºéŸ³å¤±è´¥:", e);
                                startRecording();
                            };

                            audio.play().catch(e => {
                                console.error("æ’­æ”¾å”¤é†’æç¤ºéŸ³è¢«é˜»æ­¢:", e);
                                startRecording();
                            });

                        } else if (msg.event === 'wake_word_bypassed') {
                            // å¦‚æœæ­£åœ¨å¤„ç†ï¼Œå¿½ç•¥è·³è¿‡å”¤é†’è¯
                            if (status.className.includes('processing')) {
                                console.log('æ­£åœ¨å¤„ç†ä¸­ï¼Œå¿½ç•¥è·³è¿‡å”¤é†’è¯');
                                return;
                            }
                            setWakeStatus('å·²è·³è¿‡å”¤é†’è¯ï¼Œç›´æ¥è¯†åˆ«ä¸­...');
                            if (btnWakeBypass) btnWakeBypass.style.display = 'none';
                            updateUI('recording');
                            hasWoken = true;
                            silenceAccumMs = 0;
                            silenceGuardUntil = Date.now() + SILENCE_GUARD_MS;
                        } else if (typeof msg.text === 'string') {
                            // å¦‚æœæ­£åœ¨å¤„ç†ï¼Œå¿½ç•¥æ–°çš„è¯­éŸ³è¾“å…¥
                            if (status.className.includes('processing')) {
                                console.log('æ­£åœ¨å¤„ç†ä¸­ï¼Œå¿½ç•¥æ–°çš„è¯­éŸ³è¾“å…¥');
                                return;
                            }
                            
                            // æ”¶åˆ° ASR æ–‡æœ¬ï¼ˆåœ¨çº¿æˆ–ç¦»çº¿ï¼‰
                            lastRecognizedText = msg.text;
                            recognizedTextDiv.textContent = msg.text;
                            const conf = typeof msg.confidence === 'number' ? (msg.confidence * 100).toFixed(1) + '%' : '';
                            recognitionMeta.innerHTML = `${conf ? ('ç½®ä¿¡åº¦: ' + conf) : ''}`;
                            recognitionResult.style.display = 'block';
                            textInput.value = msg.text; // åŒæ­¥åˆ°è¾“å…¥æ¡†ï¼ˆéšè—æ€ï¼‰

                            // æ¯ä¸€æ¬¡è¯†åˆ«å¢é‡éƒ½è§†ä¸ºæ´»è·ƒè¯´è¯ï¼Œé‡ç½®å”¤é†’è®¡æ—¶ï¼ˆé¿å…è¿‡æ—©å›é€€ï¼‰
                            if (msg.text && msg.text.trim().length > 0) {
                                hasWoken = true;
                                silenceAccumMs = 0;
                                silenceGuardUntil = Date.now() + SILENCE_GUARD_MS;
                            }

                            // è‡ªåŠ¨å‘é€åˆ°å¤§æ¨¡å‹ï¼šå¯¹è¯†åˆ«æ–‡æœ¬åšé˜²æŠ–ï¼Œé¿å…é¢‘ç¹è¯·æ±‚
                            if (msg.text && msg.text.trim().length > 0) {
                                lastPartialText = msg.text.trim();
                                if (autoSendTimer) clearTimeout(autoSendTimer);
                                autoSendTimer = setTimeout(() => {
                                    if (!autoSendInFlight && lastPartialText.length > 0) {
                                        let textToSend = lastPartialText;
                                        autoSendInFlight = true;
                                        sendRecognizedToLLM(textToSend).finally(() => {
                                            autoSendInFlight = false;
                                            lastPartialText = '';
                                        });
                                    }
                                }, 800); // 800ms æ— å¢é‡åˆ™è§¦å‘å‘é€
                            }

                            // è‹¥è¯†åˆ«æ–‡æœ¬ä¸ºç©ºï¼Œå›åˆ°ç›‘å¬æ€
                            if (!msg.text) {
                                updateUI('idle');
                            }
                        }
                    } catch (e) {
                        console.warn('WS æ–‡æœ¬æ¶ˆæ¯è§£æå¤±è´¥:', e, ev.data);
                    }
                }
            };

            ws.onclose = (ev) => {
                console.log('WebSocket closed:', ev.code, ev.reason);
                
                // å¦‚æœä»æœªè¿æ¥æˆåŠŸå°±æ–­å¼€ï¼Œå¾ˆå¯èƒ½æ˜¯è¯ä¹¦é—®é¢˜æˆ–ç«¯å£ä¸é€š
                if (!wsConnected && !wsResetting) {
                    const hint = document.getElementById('ssl-auth-hint');
                    if(hint) {
                        hint.style.display = 'block';
                        const link = document.getElementById('ssl-auth-link');
                        // å°† wss:// è½¬ä¸º https:// ä¾›ç”¨æˆ·ç‚¹å‡»è®¿é—®
                        if (link) {
                            const loc = window.location;
                            const host = loc.hostname || 'localhost';
                            const port = loc.port ? `:${loc.port}` : '';
                            // å»æ‰å½“å‰ç«¯å£åï¼Œæ”¹ä¸º 1337
                            link.href = `${loc.protocol}//${host}:1337`;
                        }
                    }
                }

                wsConnected = false;
                // å¦‚æœæ˜¯æˆ‘ä»¬ä¸»åŠ¨çš„é‡å¯æµç¨‹ï¼Œä¸è¦æŠ›å‡ºâ€œè¿æ¥å·²å…³é—­â€çš„æç¤º
                if (wsResetting) return;
                if (wsAutoReconnect) {
                    setWakeStatus('è¿æ¥æ–­å¼€ï¼Œé‡è¯•ä¸­...');
                    setTimeout(initWebSocket, 1500);
                } else {
                    setWakeStatus('è¿æ¥å·²å…³é—­');
                }
            };

            ws.onerror = () => {
                setWakeStatus('è¿æ¥å‡ºé”™');
            };
        }

        function floatToPCM16Int16Array(float32Array) {
            const len = float32Array.length;
            const out = new Int16Array(len);
            for (let i = 0; i < len; i++) {
                let s = Math.max(-1, Math.min(1, float32Array[i]));
                out[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
            }
            return out;
        }
        function concatInt16(a, b) {
            if (!a || a.length === 0) return b;
            if (!b || b.length === 0) return a;
            const out = new Int16Array(a.length + b.length);
            out.set(a, 0);
            out.set(b, a.length);
            return out;
        }

        function resampleTo16k(inputFloat32, inSampleRate) {
            if (inSampleRate === 16000) return inputFloat32;
            const sampleRateRatio = inSampleRate / 16000;
            const newLength = Math.round(inputFloat32.length / sampleRateRatio);
            const result = new Float32Array(newLength);
            let offsetResult = 0;
            let offsetBuffer = 0;
            while (offsetResult < result.length) {
                const nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);
                // ç®€å•å¹³å‡æ³•
                let accum = 0, count = 0;
                for (let i = offsetBuffer; i < nextOffsetBuffer && i < inputFloat32.length; i++) {
                    accum += inputFloat32[i];
                    count++;
                }
                result[offsetResult] = count > 0 ? (accum / count) : 0;
                offsetResult++;
                offsetBuffer = nextOffsetBuffer;
            }
            return result;
        }

        async function startMicAndStream() {
            try {
                if (!audioCtx) {
                    const AC = window.AudioContext || window.webkitAudioContext;
                    try { audioCtx = new AC({ sampleRate: 16000 }); }
                    catch(_) { audioCtx = new AC(); }
                } else if (audioCtx.state === 'suspended') {
                    try { await audioCtx.resume(); } catch (_) {}
                }
                micStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true, channelCount: 1 } });
                const source = audioCtx.createMediaStreamSource(micStream);
                // 4096 å¸§ï¼Œ1 è¾“å…¥/è¾“å‡ºé€šé“
                processor = audioCtx.createScriptProcessor(4096, 1, 1);
                source.connect(processor);
                processor.connect(audioCtx.destination);

                processor.onaudioprocess = (e) => {
                    if (!ws || ws.readyState !== 1) return;
                    if (audioCtx.state === 'suspended') return; // æœªæ¿€æ´»åˆ™ä¸å¤„ç†
                    if (window.isPlayingWakeSound) return; // æ­£åœ¨æ’­æ”¾å”¤é†’æç¤ºéŸ³ï¼Œæš‚åœå½•éŸ³
                    
                    // å›å£°æ¶ˆé™¤ï¼šæµè§ˆå™¨å·²å¼€å¯ echoCancellationï¼Œæ­¤å¤„ä¸å†ä¸¢å¼ƒæ•°æ®
                    // if (window._isAiSpeaking) { ... }

                    const input = e.inputBuffer.getChannelData(0);
                    const resampled = resampleTo16k(input, audioCtx.sampleRate);
                    const int16 = floatToPCM16Int16Array(resampled);
                    // é™éŸ³æ£€æµ‹ï¼šç»Ÿè®¡å½“å‰å¸§å¹³å‡ç»å¯¹å¹…åº¦ï¼ˆå«å”¤é†’åä¿æŠ¤æœŸï¼‰
                    let absSum = 0;
                    for (let i = 0; i < int16.length; i++) { absSum += Math.abs(int16[i]); }
                    const absAvg = int16.length ? (absSum / int16.length) : 0;
                    const CHUNK = 960; // çº¦ 60ms@16k
                    const nowTs = Date.now();
                    const guardActive = hasWoken && nowTs < (silenceGuardUntil || 0);
                    if (!guardActive) {
                        if (absAvg < SILENCE_ABS_THRESH) {
                            silenceAccumMs += Math.round(int16.length / 16); // int16.length/16000 ç§’ -> msï¼ˆè¿‘ä¼¼ï¼‰
                        } else {
                            // æœ‰å£°éŸ³ç›´æ¥æ¸…é›¶ï¼Œç­‰æ•ˆâ€œç»­æœŸâ€
                            silenceAccumMs = 0;
                        }
                    } else {
                        // å”¤é†’åçŸ­ä¿æŠ¤æœŸå†…ä¸ç´¯è®¡é™éŸ³ï¼Œé¿å…â€œåˆšå”¤é†’å°±å›é€€â€
                        silenceAccumMs = 0;
                    }
                    if (hasWoken && !guardActive && silenceAccumMs >= SILENCE_TIMEOUT_MS) {
                        // ä»…åœ¨å·²å”¤é†’ä¸”éä¿æŠ¤æœŸå†…æ‰å›åˆ°å”¤é†’ç›‘å¬
                        resetToWakeListening('é•¿æ—¶é—´é™éŸ³ï¼Œå·²è¿”å›å”¤é†’ç›‘å¬');
                        return;
                    }
                    // ç´¯ç§¯å¹¶æŒ‰ 960 é‡‡æ ·åˆ‡ç‰‡å‘é€ï¼ˆä¸å®˜æ–¹ demo ä¿æŒä¸€è‡´ï¼‰
                    pendingPCM = concatInt16(pendingPCM, int16);
                    while (pendingPCM.length >= CHUNK) {
                        const chunk = pendingPCM.slice(0, CHUNK);
                        pendingPCM = pendingPCM.slice(CHUNK);
                        try { ws.send(chunk.buffer); sentChunks++; } catch (_) { /* noop */ }
                    }
                };

                
                setWakeStatus('æœ¬åœ°é‡‡é›†ä¸­ï¼Œç­‰å¾…åç«¯ç¡®è®¤ç›‘å¬...');
            } catch (err) {
                console.error('éº¦å…‹é£åˆå§‹åŒ–å¤±è´¥:', err);
                showError('æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æƒé™');
                setWakeStatus('éº¦å…‹é£ä¸å¯ç”¨');
            }
        }



        async function stopMicAndStream(reasonText) {
            try {
                if (processor) {
                    try { processor.disconnect(); } catch (_) {}
                    processor.onaudioprocess = null;
                    processor = null;
                }
                if (micStream) {
                    try { micStream.getTracks().forEach(t => t.stop()); } catch (_) {}
                    micStream = null;
                }
                // å¯é€‰ï¼šæš‚åœéŸ³é¢‘ä¸Šä¸‹æ–‡ä»¥èŠ‚çœèµ„æº
                if (audioCtx && audioCtx.state !== 'suspended') {
                    try { await audioCtx.suspend(); } catch (_) {}
                }
            } finally {
                pendingPCM = new Int16Array(0);
                silenceAccumMs = 0;
                sentChunks = 0;
                micEnabled = false;
                wakeBypassed = false; // é‡ç½®æ—è·¯çŠ¶æ€
                btnWakeEnableMic.textContent = 'ğŸ¤ å¯ç”¨ç›‘å¬';
                btnWakeEnableMic.style.background = '#2196F3';
                // éšè—"è·³è¿‡å”¤é†’è¯"æŒ‰é’®
                if (btnWakeBypass) btnWakeBypass.style.display = 'none';
                // é€šçŸ¥åç«¯å…³é—­å”¤é†’ç›‘å¬
                sendCtrl({ wake_word_enabled: false, is_speaking: false });
                // å…³é—­å¹¶æ¸…ç† WSï¼Œé¿å…ä¼šè¯çŠ¶æ€æ®‹ç•™
                wsAutoReconnect = false;
                if (ws) { try { ws.close(); } catch (_) {} ws = null; }
                updateUI('idle');
                setMicFabActive(false);
                if (reasonText) setWakeStatus(reasonText);
            }
        }

        // é™éŸ³è¶…æ—¶åå›åˆ°å”¤é†’ç›‘å¬ï¼šä»…é‡å¯ WebSocketï¼Œä¼šä¿ç•™éº¦å…‹é£é‡‡é›†
        async function resetToWakeListening(reasonText){
            try{
                hasWoken = false;
                wsResetting = true;
                // 1) å…³é—­å¹¶é‡å»º WSï¼Œä¼šè¯æ¸…é›¶
                if (ws) { try { ws.close(); } catch(_){} ws = null; }
                wsAutoReconnect = false;
                initWebSocket();
                const ok = await waitWsOpen(4000);
                if(!ok){ wsResetting=false; setWakeStatus('è¿æ¥åç«¯å¤±è´¥ï¼Œè¯·é‡è¯•'); return; }
                // 2) é‡æ–°ä¸‹å‘å”¤é†’è¯å¹¶å¼€å¯é—¨æ§
                sendCtrl({ wake_word: WAKE_WORD });
                sendCtrl({ wake_word_enabled: true, is_speaking: true });
                // 3) ä¸åœæ­¢æœ¬åœ°éº¦å…‹é£é‡‡é›†ï¼Œä¿æŒ processor/micStream ä¸å˜
                // 4) UI åˆ‡ä¸º"ç©ºé—²"ï¼ˆä¸æ˜¾ç¤ºå½•éŸ³åŠ¨ç”»ï¼‰ï¼Œå¹¶ç›´æ¥æç¤ºç›‘å¬ä¸­
                setMicFabActive(false);
                updateUI('idle');
                if (btnWakeBypass) btnWakeBypass.style.display = 'inline-block';
                setWakeStatus(`ç›‘å¬ä¸­ï¼š${WAKE_WORD}`);
            }catch(e){ console.warn('resetToWakeListening error', e); }
            finally{ wsResetting = false; }
        }

        // è½¯é‡ç½®ï¼šä»…å›åˆ°å”¤é†’ç›‘å¬ï¼Œä¸é‡å¯WebSocketã€ä¸åœæ­¢éº¦å…‹é£
async function softResetToWakeListening(reasonText){
    try{
        // æ¸…ç†å‰ç«¯è®¡æ•°ä¸ç¼“å­˜ï¼Œä½†ä¿ç•™ws/mic
        silenceAccumMs = 0;
        pendingPCM = new Int16Array(0);
        sentChunks = 0;
        // é€šçŸ¥æœåŠ¡ç«¯ç»“æŸæœ¬æ¬¡è®²è¯ï¼Œæ¸…ç†ç¼“å­˜
        sendCtrl({ is_speaking: false });
        // é‡æ–°ä¸‹å‘å”¤é†’è¯ä¸å¼€å¯ç›‘å¬é—¨æ§
        sendCtrl({ wake_word: WAKE_WORD });
        sendCtrl({ wake_word_enabled: true, is_speaking: true });
        // UI åˆ‡ä¸ºâ€œç©ºé—²â€ï¼Œä¸æ˜¾ç¤ºå½•éŸ³åŠ¨ç”»
        setMicFabActive(false);
        updateUI('idle');
        if (btnWakeBypass) btnWakeBypass.style.display = 'inline-block';
        if (reasonText) setWakeStatus(reasonText); else setWakeStatus('å·²è¿”å›å”¤é†’ç›‘å¬ï¼Œç­‰å¾…å”¤é†’è¯...');
    }catch(e){ console.warn('softResetToWakeListening error', e); }
}

// è·³è¿‡å”¤é†’è¯
        btnWakeBypass.addEventListener('click', () => {
            wakeBypassed = true;
            sendCtrl({ wake_word_bypass: true });
            
            setWakeStatus('å·²è·³è¿‡å”¤é†’è¯ï¼Œç›´æ¥è¯†åˆ«ä¸­...');
        });

        // å¯ç”¨/å…³é—­éº¦å…‹é£ç›‘å¬ï¼ˆæŒ‰é’®åˆ‡æ¢ï¼‰
        btnWakeEnableMic.addEventListener('click', async () => {
            if (!micEnabled) {
                // é‡æ–°å»ºç«‹ WS ä¼šè¯ï¼Œé‡ç½®æœåŠ¡ç«¯çŠ¶æ€
                wsAutoReconnect = true;
                initWebSocket();
                const ok = await waitWsOpen(4000);
                if (!ok) {
                    setWakeStatus('è¿æ¥åç«¯å¤±è´¥ï¼Œè¯·é‡è¯•');
                    return;
                }
                // é‡å‘å”¤é†’è¯ï¼Œç¡®ä¿ä»¥æœ€æ–°çš„è¯å¼€å§‹ç›‘å¬
                sendCtrl({ wake_word: WAKE_WORD });
                // å¼€å¯ç›‘å¬
                sendCtrl({ wake_word_enabled: true, is_speaking: true });
                // å†å¯åŠ¨æœ¬åœ°éº¦å…‹é£æ¨æµ
                await startMicAndStream();

                micEnabled = true;
                btnWakeEnableMic.textContent = 'â¹ï¸ å…³é—­ç›‘å¬';
                btnWakeEnableMic.style.background = '#f44336';
                setWakeStatus('éº¦å…‹é£å·²å¯ç”¨ï¼Œæ­£åœ¨ç›‘å¬å”¤é†’è¯...');
                updateUI('idle'); // æ›´æ–°çŠ¶æ€æ˜¾ç¤ºä¸º"å”¤é†’è¯ï¼šä¹Œè¨å¥‡"
                if (btnWakeBypass) btnWakeBypass.style.display = 'inline-block';
            } else {
                await stopMicAndStream('å·²å…³é—­ç›‘å¬');
            }
        });


        // çƒ­è¯æ›´æ”¹åï¼Œä¹ŸåŒæ­¥ç»™ WS åç«¯
        document.getElementById('hotwordsInput').addEventListener('blur', () => {
            const hotwords = getHotwords();
            if (hotwords) sendCtrl({ hotwords });
        });

        // é¡µé¢åŠ è½½å³å¯åŠ¨
        (async () => {
            
            initWebSocket();
            setWakeStatus('è¯·ç‚¹å‡»â€œå¯ç”¨ç›‘å¬â€å¼€å§‹éº¦å…‹é£é‡‡é›†');
        })();
        // ===== ç»“æŸï¼šå”¤é†’è¯ + WebSocket å®æ—¶æµ =====
    </script>
</body>
</html>

